<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daydust&#39;s Blog</title>
  
  <subtitle>道阻且长，行则将至</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-02-24T06:00:00.761Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>庆尘</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟号码场景下的逻辑漏洞挖掘</title>
    <link href="http://example.com/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <id>http://example.com/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</id>
    <published>2024-02-24T02:30:53.000Z</published>
    <updated>2024-02-24T06:00:00.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>由于最近挖洞遇到的虚拟号码场景比较多，且都存在各种各样的问题，所以本篇文章来总结一下在该场景下应该如何有效地，快速地进行逻辑漏洞挖掘（文章中涉及真实信息，所以厚码，见谅）</p><h1 id="一、漏洞分析"><a href="#一、漏洞分析" class="headerlink" title="一、漏洞分析"></a>一、漏洞分析</h1><p>这里要讲的虚拟号码场景，应该不少师傅也都遇到过，一般流程如下</p><blockquote><p>某些功能需要提供用户A手机号给用户B查看并拨打时，往往为了保护用户的隐私安全，就会<strong>提供与用户A手机号绑定的虚拟号码给用户B</strong>，这时B拨打虚拟号码就会转接给A，这样用户B就不会获取到A的真实手机号，同时这样的虚拟号码一般都带有自动保存录音的功能，所以大大保障了用户的隐私安全与数据安全</p></blockquote><p>通过上面的流程，可以发现使用虚拟号码的最大目的——隐藏用户的真实手机号，保护用户的隐私安全，如下</p><p>![屏幕截图 2024-02-24 105956](屏幕截图 2024-02-24 105956.png)</p><p>那我们有没有可能绕过该功能<strong>获取到用户的真实手机号</strong>呢，答案是肯定的，并且我目前挖企业SRC中遇到的该场景，99%都是存在问题的（就是<strong>我目前遇到的该场景都存在该问题</strong>，但肯定有做得好，并且不存在该问题的，只是我还没有发现）</p><p>该问题就是<strong>用户真实手机号的泄露</strong>，也就是使用了虚拟号码的场景，就极大概率存在真实号码的泄露，但泄露的位置可能有很多种，下面来看几个我遇到的真实案例</p><h1 id="二、漏洞案例"><a href="#二、漏洞案例" class="headerlink" title="二、漏洞案例"></a>二、漏洞案例</h1><h2 id="1、用户主页信息的泄露"><a href="#1、用户主页信息的泄露" class="headerlink" title="1、用户主页信息的泄露"></a>1、用户主页信息的泄露</h2><p>这个比较简单，场景如下</p><p>![屏幕截图 2024-02-24 111249](屏幕截图 2024-02-24 111249.png)</p><p>该平台由于功能与业务要求，所以会在<strong>用户（例如商家）的主页</strong>提供虚拟号码的服务，以供其他用户联系。</p><p>这个功能点也一目了然吧，直联老板就是获取电话，点击之后出现加密号码，如下</p><p>![屏幕截图 2024-02-24 111743](屏幕截图 2024-02-24 111743.png)</p><p>注意这里写的是“本次通过将通过<strong>加密号码呼出</strong>”，并没有说提供的号码是加密的号码，那如何确认提供的号码是不是加密号码呢？很简单，<strong>换一个浏览器或者账号</strong>，再获取一次，看两次是不是一样的就行了，如下</p><p>![屏幕截图 2024-02-24 112250](屏幕截图 2024-02-24 112250.png)</p><p>可以看到两次是不一样的，说明这确实是加密的号码，而真实号码的泄露，就存在于<strong>该页面的回显</strong>中，如下</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/%E5%9B%BE%E7%89%871.png" alt="图片1"></p><p>可以看到泄露的信息已经非常全了，所以这个漏洞也算是特别简单的一个漏洞，这里就是在<strong>用户主页</strong>，F12刷新，在请求商家信息的回显数据包的js中，存在信息泄露</p><p>猜测该漏洞存在的原因是请求商家信息的回显中没有做好脱敏处理</p><h2 id="2、用户搜索结果的泄露"><a href="#2、用户搜索结果的泄露" class="headerlink" title="2、用户搜索结果的泄露"></a>2、用户搜索结果的泄露</h2><p>这个漏洞与上一个漏洞的不同之处就在于信息泄露的位置不一样，首先用户的主页也是可以获取到虚拟号码，如下</p><p>![屏幕截图 2024-02-24 114242](屏幕截图 2024-02-24 114242.png)</p><p>在该主页，虽然存在虚拟号码的功能，但这里是不存在任何的信息泄露的，也就是无法绕过虚拟号获取用户的真实手机号，那这里就不存在漏洞了吗，继续往下看</p><p>其实该信息泄露的漏洞是位于搜索结果处</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224120835202.png" alt="image-20240224120835202"></p><p>简而言之也是用户信息回显未做脱敏，上一个漏洞是在<strong>用户的主页获取用户信息时未脱敏</strong>，而这里是在搜索用户时，<strong>结果列表获取用户的信息未脱敏</strong>，如下</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224115530167.png" alt="image-20240224115530167"></p><p>也就是在搜索接口的回显中，会泄露搜索结果中的所有用户的真实电话号</p><p>并且这里只有找店铺才可以（因为店铺才有电话号信息）</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224120324233.png" alt="image-20240224120324233"></p><p>也就是想获取哪个用户的真实电话，就搜哪个用户，抓包看该接口的回显就行了，即跟上一个漏洞一样，也是可以获取全平台的用户真实电话</p><p>最后这个洞给了我<strong>低危，25块</strong>，整个人都不好了**(˚ ˃̣̣̥᷄⌓˂̣̣̥᷅ )**</p><p>第二天想battle的时候就已经修了，变成了下面这样用*代替</p><p>![屏幕截图 2024-02-24 121024](屏幕截图 2024-02-24 121024.png)</p><p>懒得去扯了，不响丸辣，唉</p><h2 id="3、虚拟号码生成处的泄露"><a href="#3、虚拟号码生成处的泄露" class="headerlink" title="3、虚拟号码生成处的泄露"></a>3、虚拟号码生成处的泄露</h2><p>上面两个漏洞是由于数据未脱敏导致的，但这个洞是单纯的逻辑有问题导致的泄露，如下</p><p>![屏幕截图 2024-02-24 121456](屏幕截图 2024-02-24 121456.png)</p><p>与第一个漏洞是同一个场景，但是利用方式不同，在该位置开启抓包，并点击<strong>直联老板</strong>，会抓到一个获取真实电话号的包，如下</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224121807596.png" alt="image-20240224121807596"></p><p>分析一下这里的请求逻辑，大概如下</p><p><strong>点击直联老板—获取老板的真实手机号—将真实手机号进行加密—获取加密后的手机号—展示加密后的手机号</strong></p><p>所以这里抓包的话，就可以获取到老板的真实手机号手机号，实际上应该进行对明文手机号进行数据加密的，所以这里应该算是设计缺陷了</p><h2 id="4、首页推荐信息的泄露"><a href="#4、首页推荐信息的泄露" class="headerlink" title="4、首页推荐信息的泄露"></a>4、首页推荐信息的泄露</h2><p>这里也是一个回显信息的未脱敏导致的漏洞，但位置不同</p><p>首先在各种商城以及律师咨询平台，医生咨询平台，教师咨询平台等各种职业咨询平台中，是不是都会存在一个<strong>首页推荐</strong>的功能点，例如精选商品，推荐医师，推荐律师等等，而它们的一部分信息就会展示到首页中，例如职业人员的名称，擅长的技能等，这些信息肯定是来自于一个<strong>获取首页推荐信息的接口</strong>，那这个接口会不会导致信息泄露呢？答案是肯定的</p><p>例如首页推荐接口获取一个医生或律师的全部信息，但其中只有头像，名字和擅长技能在首页展示，而该接口获取的信息远不止这些，并且未脱敏的情况下，也就造成了敏感信息泄露，来看看下面这个场景</p><p>![屏幕截图 2024-02-24 123812](屏幕截图 2024-02-24 123812.png)</p><p>可以看到首页推荐了一些从业者，以便用户能快速选择并咨询</p><p>进入从业者主页后，如果想要联系从业者，可以选择<strong>获取从业者的虚拟号码拨打</strong>，或者<strong>缴费之后留下自己的电话，等待从业者回电</strong></p><p>注意，两种方式都是无法获取从业者的真实电话的，如下</p><p><strong>获取虚拟号进行拨打</strong></p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224124317398.png" alt="image-20240224124317398"></p><p><strong>缴费之后等待从业者回电</strong></p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224124438799.png" alt="image-20240224124438799"></p><p>这里的漏洞就存在于主页获取首页推荐内容的接口中，回到主页刷新，抓到获取首页推荐内容的接口即可</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224124952851.png" alt="image-20240224124952851"></p><p>可以看到获取首页推荐内容的接口，虽然在首页展示的只有姓名和擅长领域，但其实真实姓名（有的从业者会用别称）和真实电话，也会同时获取，只是不被展示在首页，所以这就是在获取首页推荐信息的接口处存在的敏感信息泄露漏洞的表现形式。</p><p>这个全平台从业者真实信息，最后给了我<strong>中危50块</strong>（光缴费等待从业者回电都要缴99元子。。。）</p><p>心情更不好了**(ᇂ_ᇂ|||)**</p><h2 id="5、脱敏数据接口绕过的泄露"><a href="#5、脱敏数据接口绕过的泄露" class="headerlink" title="5、脱敏数据接口绕过的泄露"></a>5、脱敏数据接口绕过的泄露</h2><p>这个也是首页推荐信息的泄露，但和上一个漏洞不同的是，获取首页推荐信息的接口是做了脱敏的，那有师傅就要问了，脱敏了为什么还能从中获取敏感信息呢？答案就是它这个脱敏是可以被绕过的，并且这个场景和上面四个是不一样的，算是变相的“虚拟号码”场景，一起来看看吧。</p><p>首先来到商家的主页，如下</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224130145037.png" alt="image-20240224130145037"></p><p>注意，由于业务需要，这里的“电话”是可以公开的，也就是点击之后可以直接获取真实电话的，没有任何的加密号码，如下</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224130359490.png" alt="image-20240224130359490"></p><p>那这里电话都出来了，还泄露什么呢？其实还是泄露电话，再往下看漏洞点，同样也是抓取获取首页推荐信息的数据包，接口如下</p><p><code>https://xxxx.com/xxx/search/recommend?ajax=1&amp;device=pc&amp;pageSource=home&amp;strategy=view&amp;pageSize=1&amp;page=1&amp;category=20900,20600,20200,20500,20000,20400,20700,20800,20300,20100,21000&amp;multicat=2</code></p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224131212532.png" alt="image-20240224131212532"></p><p>这里该接口的回显中只有商家的公开信息，也就是首页推荐展示的信息，是没有危害的</p><p>但观察接口，接口存在一个multicat参数，并且值为2，将其修改为1，结果如下</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224131558320.png" alt="image-20240224131558320"></p><p>可以看到出现了敏感信息，商家的邮箱，电话。但这里为什么会有两个电话呢，其实要思考一个问题，那就是商家预留的用于让用户联系的电话，就一定是商家注册平台账户时用的电话吗？不一定吧，猜测商家端应该有一个功能，可以自由设置展示在平台用于客户联系的电话，经过验证，也就是这里的call_contact，而form_contact自然就是商家注册平台时所用的电话号</p><p>普通用户只能看到call_contact，也就是商家设置的让客户看到的信息，而商家的真实电话号和邮箱，普通用户是无法获取，自然也就是存在漏洞了</p><h1 id="三、重磅工具"><a href="#三、重磅工具" class="headerlink" title="三、重磅工具"></a>三、重磅工具</h1><p>看了上面的案例，有的师傅就要问了，这么多存在泄露的位置，我难道要挨个去找吗，那当然是不用的，只需要一个插件，就能让你省去繁琐的查找敏感信息的工作，就是——<strong>HAE</strong></p><p>Hae这款工具很多师傅都用过，但大部分人都感觉不太行，但我个人觉得<strong>好的正则匹配规则</strong>配合<strong>新版Hae的展示台</strong>，对敏感信息的泄露这一类漏洞的挖掘，是有非常大的帮助的，并且也非常方便</p><p>一般测试漏洞的流程，就是开启Burp然后测各种场景，各种功能点，中间也不需要来看Hae插件，测完漏洞要下班之前，再来到Hae的展示台，挨个分析一下匹配到的敏感数据，特别是人名，电话号以及各种key，这样说可能有些师傅不太能感受到冲击力，可以看看下面这两张图</p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224134233516.png" alt="image-20240224134233516"></p><p><img src="/2024/02/24/%E8%99%9A%E6%8B%9F%E5%8F%B7%E7%A0%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/image-20240224134427958.png" alt="image-20240224134427958"></p><p>当师傅们准备下班的时候来到Hae看到这一幕，我相信师傅们应该都会很高兴吧,并不需要刻意地去测试这类漏洞，只要把Hae开着，测试漏洞时不用看Hae，下班之前来Hae展示台看一眼，挨个分析一下匹配到的数据就行了</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>因为我也靠Hae挖到了不少的漏洞，所以我个人比较推崇这款插件，但不得不说的是，当数据包过多的时候，Hae插件确实容易崩溃，而且Hae插件也比较吃内存，所以我通常都是<strong>两小时分析一次</strong>，分析之后把Hae抓到的数据包全部clean，也就是清空掉，或者分析之后重启burp，这样就可以解决当Hae积攒的数据包过大过多之后，hae插件崩溃或卡死的情况，至于吃内存的问题，新版的Hae相比老版已经好了很多，相信未来这个问题也会逐步得到解决。</p><p>最后，祝挖洞的师傅们天天有高危，月月有严重，respect！</p>]]></content>
    
    
    <summary type="html">由于最近挖洞遇到的虚拟号码场景比较多，且都存在各种各样的问题，所以本篇文章来总结一下在该场景下应该如何有效地，快速地进行逻辑漏洞挖掘</summary>
    
    
    
    <category term="SRC挖掘" scheme="http://example.com/categories/SRC%E6%8C%96%E6%8E%98/"/>
    
    
    <category term="逻辑漏洞" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="SRC挖掘" scheme="http://example.com/tags/SRC%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>审计SQL注入时的小tips</title>
    <link href="http://example.com/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/"/>
    <id>http://example.com/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/</id>
    <published>2023-12-21T15:57:16.000Z</published>
    <updated>2023-12-21T16:38:16.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前景提要"><a href="#一、前景提要" class="headerlink" title="一、前景提要"></a>一、前景提要</h1><p>起因是因为审计完rbac项目之后，把审计报告发到博客。过了一段时间有位师傅跟我说这个项目还有一个SQL注入我没有审计到，我寻思这个项目用的Mybatis框架，我记得SQL语句用$拼接参数的地方我都审了，不应该有遗漏诶。经过一番交流之后发现确实遗漏了一个注入点，但这个注入点的利用也比较巧，所以写一篇博客来记录和分享一下这个注入点的挖掘和利用。</p><h1 id="二、代码审计"><a href="#二、代码审计" class="headerlink" title="二、代码审计"></a>二、代码审计</h1><h2 id="1、源码分析"><a href="#1、源码分析" class="headerlink" title="1、源码分析"></a>1、源码分析</h2><p>项目就还是我以前文章的rbac项目，所以就不分析其他的了，我们直接来看有问题的Mapper文件代码，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703149223148-686319fa-1a07-4b2d-b00f-880f176fb949.png" alt="img"></p><p>使用了${ancestors}拼接参数，追踪到Dao层，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703149470682-2d913ba9-b2ad-48c4-b16c-fcdf172fc404.png" alt="img"></p><p>追踪到实现类，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703149648177-012c9604-7d2a-437f-89b6-ffb8df913a68.png" alt="img"></p><p>可以看到在实现类的<strong>updateParentDeptStatus</strong>方法调用了<strong>updateDeptStatus</strong>方法，我们再追踪到调用<strong>updateParentDeptStatus</strong>方法的位置，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703150164512-b410e7f9-704b-4d9b-ae7a-1f92c3b54de8.png" alt="img"></p><p>看到是实现类的<strong>updateDept</strong>方法调用了<strong>updateParentDeptStatus</strong>方法，继续追踪，来到Controller层</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703150351333-0192cf99-4f28-4587-ae0f-71bea90372a9.png" alt="img"></p><p>可以看到Controller层代码处理了传入的Mydept对象，处理的过程中调用<strong>updateDept</strong>方法</p><p>同时Mydept实体类的代码如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703150511937-160cdf9a-8b58-440a-adf1-7920117a2a60.png" alt="img"></p><p>现在我们理一下上面的输入流转过程，如下</p><ul><li>1、用户输入，传入Mydept对象,命名为为dept</li><li>2、Controller层调用updateDept(dept)</li><li>3、updateDept方法调用updateParentDeptStatus(dept)</li><li>4、updateParentDeptStatus方法调用了updateDeptStatus(dept)</li><li>5、进入DeptDao</li><li>6、Mabatis获取传入的Dept实例的ancestors属性值，并执行对应的update语句</li></ul><p>咋一看是不是一个很简单的注入，但是仔细看看第四步的代码，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703151419832-34b4b82d-4f5e-4fbd-a978-9d935f895ac7.png" alt="img"></p><p>获取传入的dept实例的dept_id属性值，并根据这个id值从数据库获取对应的dept实例，再将数据库获取的dept赋值为dept，即覆盖了我们传入的dept实例</p><p>那这里被覆盖之后的dept的ancestors属性值还会是我传入的dept属性值吗？当然就不是了，而是根据传入的id值从数据库中取出来的</p><p>说明了什么？说明针对这个输入流转，我们的ancestors值是不可控的，所以<strong>从这个点来看</strong>，是不存在注入的（我第一次审计就是看到这就认为不存在SQL注入，就没继续了，所以错过了这个漏洞）</p><p>这里为什么要强调“<strong>从这个点来看</strong>”？</p><p><em><strong>这里就引出一个平时审计SQL注入漏洞时需要注意的点了，当某个存在SQL注入的参数在当前输入流转不可控时，可以找找其他地方，看能否通过其他功能修改该参数，从而使该参数可控</strong></em></p><p>那怎么找呢？找能够控制该参数的对应方法即可，例如这里参数不可控的原因是因为<strong>参数是从数据库取出来的</strong>，那我们就可以找找什么地方可以修改数据库中的这个值，即在对应的mapper文件中找找<strong>insert语句</strong>和<strong>update语句</strong></p><p>这里共有三个update语句，并没有insert，所以下面我们来逐个看看这三个update语句</p><h2 id="2、漏洞定位"><a href="#2、漏洞定位" class="headerlink" title="2、漏洞定位"></a>2、漏洞定位</h2><h3 id="2-1、第一个update"><a href="#2-1、第一个update" class="headerlink" title="2.1、第一个update"></a>2.1、第一个update</h3><p>第一个update语句如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703162908062-33aa35b5-53f6-4720-9f6e-e9ba6b84d285.png" alt="img"></p><p>可以看到这个update语句的作用就是设置指定id的部门的ancestors为指定值<img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703165619006-15f34324-0f05-4a2c-9ac1-e60f3442e2cb.png" alt="img"></p><p>经过追踪，发现该方法传入的ancestors只能是如下</p><pre><code class="java">String newAncestors = parentInfo.getAncestors() + &quot;,&quot; + parentInfo.getDeptId();即&#123;上级部门ancestors,上级部门id&#125;</code></pre><p>显然我们要控制此处的ancestors为恶意payload是不可能的（因为部门id我们是不可控的），所以这个点放弃</p><h3 id="2-2、第二个update"><a href="#2-2、第二个update" class="headerlink" title="2.2、第二个update"></a>2.2、第二个update</h3><p>第二个update语句如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703166128324-365f722b-4c0c-4cd8-866b-3da4aeb94dbf.png" alt="img"></p><p>将数据库中指定id的dept信息换为传入的dept信息，其中就包含了ancestors参数，所以只要我们能够控制传入dept实例的ancestors属性值，就能够修改数据库中对应的ancestors，造成SQL注入漏洞</p><p>所以我们向上追踪一下，先来到Dao层，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703166387564-3a645225-6f3b-40f2-9905-f74d99fcf2b3.png" alt="img"></p><p>来到实现类<img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703166970724-fa8268af-aebe-4a57-baf6-4d9dbeb205df.png" alt="img"></p><p>可以看到实现类中，传入的dept对象如果<strong>有上级部门</strong>，并且<strong>当前dept对象不为空</strong>，就会进入到if判断逻辑内部，这里if判断逻辑我们再分析第一个update时也分析过了，会<strong>修改我们传入的dept对象的ancestors属性值</strong></p><p>如果我们想要插入恶意ancestors，自然就不能让程序修改我们输入的ancestors属性值，也就是不进入这个if判断逻辑，就不能满足“<strong>有上级部门</strong>，并且<strong>当前dept对象不为空</strong>”这个条件</p><ul><li><p>首先是dept对象不为空</p><ul><li>我们传入的dept对象因为要带有恶意ancestors参数值，所以也肯定不会为空</li></ul></li><li><p>其次就是有上级部门</p><ul><li>所以我们要尽量保证我们传入的dept对象没有上级部门，这样就不会进入if内部导致输入的ancestors被程序修改</li></ul></li></ul><p>之后程序就会调用<strong>updateDept</strong>直接替换dept对象的信息到数据库中，我们继续向上追踪，来到Controller层</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703166737237-415d77e5-e787-4c18-be41-ff25fb46eae4.png" alt="img"></p><p>可以看到<strong>Dept对象来源于用户的请求</strong>，经过一系列逻辑判断，再调用实现类，所以我们请求该Controller方法映射的接口时，带上ancestors参数即可。并且通过观察该方法的注解，发现该方法对应程序中的“<strong>修改部门</strong>”功能</p><p>所以经过上面的分析，我们确定这个位置是可以控制数据库中的ancestors值的，只需要在<strong>“修改部门”的请求中带上ancestors参数</strong>，并且<strong>当前部门没有上级部门</strong>时，我们输入的ancestors就会覆盖数据库中ancestors参数值，即实现了ancestors参数可控</p><p>又因为刚才我们发现的SQL语句使用$拼接了ancestors参数的值，并且ancestors参数的值是从数据库中获取的，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703167629649-3ea977f4-18b7-4459-8bd2-01853ce37d5e.png" alt="img"></p><p>所以就成功了达到了SQL注入的形成条件，初步判断此处存在SQL注入，等待后面验证</p><h3 id="2-3、第三个update"><a href="#2-3、第三个update" class="headerlink" title="2.3、第三个update"></a>2.3、第三个update</h3><p>第三处update语句如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/1703167683917-d6e3e257-29a0-41fa-997c-634c52d4fa6b.png" alt="img"></p><p>这个update语句根本没涉及到ancestors参数，所以无需分析</p><h1 id="三、漏洞验证"><a href="#三、漏洞验证" class="headerlink" title="三、漏洞验证"></a>三、漏洞验证</h1><p>因为上面我们分析出这个漏洞点位于“修改部门‘功能处，所以我们来到部门管理页面<img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222002258352.png" alt="image-20231222002258352"></p><p>选定一个没有上级部门的部门，并点击编辑，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222002445871.png" alt="image-20231222002445871"></p><p>开启抓包，再点击提交按钮，发起请求，抓到如下请求包</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222002533285.png" alt="image-20231222002533285"></p><p>发现请求没有携带ancestors参数，但是我们刚才分析此处是可以传入ancestors参数的，因为接收的是Mydept类，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222002745328.png" alt="image-20231222002745328"></p><p>所以Mydept类有的属性都可以接收，My_dept类代码如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222002853888.png" alt="image-20231222002853888"></p><p>所以构造一个ancestors参数，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222003019247.png" alt="image-20231222003019247"></p><p>再结合存在漏洞的Mapper文件传入恶意payload进行闭合，如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222003117437.png" alt="image-20231222003117437"></p><p>闭合之后发送请求包，效果如下</p><p><img src="/2023/12/21/%E5%AE%A1%E8%AE%A1SQL%E6%B3%A8%E5%85%A5%E6%97%B6%E7%9A%84%E5%B0%8Ftips/image-20231222003239159.png" alt="image-20231222003239159"></p><p>SQL时间注入验证成功，所以该位置的确存在SQL注入漏洞</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>如果能够导致SQL注入的参数在对应的输入流转中不可控，可以找找其他的输入流转，看看有没有能够控制该参数的功能或方法，使用这些方法控制该参数，达到<strong>参数可控</strong>的效果，从而执行恶意SQL语句，成功利用SQL注入漏洞</p>]]></content>
    
    
    <summary type="html">记一次花样的SQL注入审计案例</summary>
    
    
    
    <category term="代码审计" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="SQL注入" scheme="http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>JTopCMS审计之目录穿越漏洞</title>
    <link href="http://example.com/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-12-09T16:46:31.000Z</published>
    <updated>2023-12-15T08:24:39.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、环境部署"><a href="#一、环境部署" class="headerlink" title="一、环境部署"></a>一、环境部署</h1><p><strong>1.1、官方网站</strong> </p><p><a href="https://www.jtopcms.com/">https://www.jtopcms.com/</a></p><p><strong>1.2、下载地址</strong> </p><p><a href="https://gitee.com/mjtop/JTopCMSV3/releases/tag/JTopCMSV3.0.2-OP">https://gitee.com/mjtop/JTopCMSV3/releases/tag/JTopCMSV3.0.2-OP</a></p><p><strong>1.3、所需环境</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>版本</strong></th></tr></thead><tbody><tr><td>JTopCMS</td><td>V3版本（开源版本）</td></tr><tr><td>Java版本</td><td>JDK1.7+即可</td></tr><tr><td>mysql</td><td>5.5.29</td></tr><tr><td>Tomcat</td><td>Tomcat7+即可</td></tr></tbody></table><p><strong>1.4、修改配置</strong></p><p>在JTopCMSV3-JTopCMSV3.0.2-OP\WebContent\WEB-INF\config\cs.properties配置文件中修改端口信息（与配置的Tomcat保持一致）与数据库连接信息</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702136878196-dc269278-ad45-4ca7-82e4-2b7fd2ad90c8.png" alt="img"></p><p><strong>1.5、启动项目</strong></p><p>启动项目之后，来到后端管理登录页面： </p><p><a href="http://127.0.0.1:7089/login_page">http://127.0.0.1:7089/login_page</a> </p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702024699410-2813cb12-624c-403d-a66e-382b1fbf01b0.png" alt="img"></p><p>登录账号密码为 admin&#x2F;jtopcms</p><h1 id="二、代码审计"><a href="#二、代码审计" class="headerlink" title="二、代码审计"></a>二、代码审计</h1><p>今天我们只针对这个应用的目录穿越漏洞进行审计，而目录穿越漏洞一般伴随<strong>文件上传&#x2F;下载&#x2F;删除</strong>等功能，所以我们先查找一下该程序是否存在文件上传&#x2F;下载&#x2F;删除功能</p><p>那审计一个项目时如何快速定义到系统的下载功能呢？</p><p>1、项目中的<strong>使用文档</strong>或<strong>用户手册</strong>。</p><p>2、部署环境后通过<strong>抓取下载数据包</strong>确定接口名后全局搜索接口名</p><p>3、使用经典<strong>关键字</strong>download等进行全局搜索即可</p><p>这里通过关键字检索，我们发现了两个疑似文件下载的接口</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702025666463-361cfa46-fbff-4aed-99f6-f768f0c57442.png" alt="img"></p><p>下面我们分别来对这两个下载功能的接口进行追踪与漏洞测试</p><h2 id="1、-downloadback-do"><a href="#1、-downloadback-do" class="headerlink" title="1、&#x2F;downloadback.do"></a>1、&#x2F;downloadback.do</h2><h3 id="（1）功能点定位"><a href="#（1）功能点定位" class="headerlink" title="（1）功能点定位"></a>（1）功能点定位</h3><p>首先定位到映射代码位于<strong>BackupSystemController类</strong>中，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702028801500-e031a3e6-9bc8-4f7d-91a4-411245d374ca.png" alt="img"></p><p>再定位到请求该接口的jsp文件中，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702029121919-e7220dd1-2626-4629-8617-1b5766390c99.png" alt="img"></p><p>通过方法名—downloadBak和该jsp文件名ManageBackup.jsp猜测该功能是一个<strong>备份文件管理功能</strong>，并且在备份下载功能中调用了该接口</p><p>所以来到后台寻找该功能点，成功定位到下载功能点，并且确实存在备份文件下载功能，功能点位于</p><ul><li><strong>后台-&gt;系统配置-&gt;系统备份管理</strong></li></ul><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702029418910-b4412cc0-318f-4546-95da-04d2ceccdd04.png" alt="img"></p><p>抓个包再次验证</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702029493283-e375518e-6fca-46bd-b429-aba998e0b9b4.png" alt="img"></p><p>进一步确认了该功能点调用了**&#x2F;downloadback.do接口**</p><h3 id="（2）源代码审计"><a href="#（2）源代码审计" class="headerlink" title="（2）源代码审计"></a>（2）源代码审计</h3><p><strong>1、Controller层</strong></p><p>根据请求包来看，<strong>target</strong>，<strong>pw</strong>，<strong>downFileInfo</strong>，这三个参数都有可能与文件下载功能有关，</p><p>我们给下载备份这个功能点<strong>下一个断点</strong>，再调试项目，看看程序的执行流程</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702094810736-6a70a1a2-d29e-478a-803b-8a7cfe875164.png" alt="img"></p><p>简化后的流程代码如下</p><pre><code class="java">@RequestMapping( value = &quot;/downloadBak.do&quot;, method = &#123; RequestMethod.POST &#125; )    public String downloadBak( HttpServletRequest request, HttpServletResponse response )        throws UnsupportedEncodingException    &#123;        // 将请求传入的参数存储在Map对象        Map params = ServletUtil.getRequestInfo( request );        // 通过session判断用户身份是否合法        .....        // 从请求中获取target参数的值，赋值为targetbak        String targetBak = ( String ) params.get( &quot;target&quot; );        // 获取系统的真实路径并赋值给base变量         String base = SystemConfiguration.getInstance().getSystemConfig().getSystemRealPath();        // 构建一个如下的字符串，并赋值testbakroot         String testBakRoot = base + &quot;__sys_bak__&quot; + File.separator + targetBak;        // 检查了名为testBakRoot的路径是否指向的是一个文件,并为其创建File对象        ......        // 开始下载File对应的文件        ......        // 关闭流        ......        // 抛出异常        ......</code></pre><p>分析上面的代码，可以看我们传入的target会被直接拼接到如下路径，在这段代码中并没有防范</p><pre><code class="plain">&#123;base&#125;/_sys_bak_/&#123;target&#125;</code></pre><p>base在我的项目中的值如下</p><pre><code class="plain">E:/WorkSpace/Javawork/JTopCMSV3-JTopCMSV3.0.2-OP/target/ROOT</code></pre><p>即拼接后的备份完整路径为（假设备份文件名为bak.zip,即target为bak.zip）</p><pre><code class="plain">E:/WorkSpace/Javawork/JTopCMSV3-JTopCMSV3.0.2-OP/target/ROOT/_sys_bak_/bak.zip</code></pre><p>于是我在</p><ul><li>E:\WorkSpace\Javawork\JTopCMSV3-JTopCMSV3.0.2-OP\target\ROOT</li></ul><p>目录下新建了一个<strong>a.txt</strong>，再请求**&#x2F;downloadbak接口**,传入的<strong>target的值改为..\a.txt</strong>，尝试拼接为如下的接口进行读取a.txt，从而验证任意文件下载漏洞</p><pre><code class="plain">E:\WorkSpace\Javawork\JTopCMSV3-JTopCMSV3.0.2-OP\target\ROOT\_sys_bak_\..\a.txt</code></pre><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702100278247-5432c485-a674-4964-8275-df450649ed00.png" alt="img"></p><p>结果如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702100499113-f6156b89-5db5-4997-9d70-a9bca7393014.png" alt="img"></p><p>可以看到被拦截了，并且给出提示：包含非法字符</p><p>控制台打印如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702109750775-aaca61bc-0885-40ec-9fbb-f3f515ab2d13.png" alt="img"></p><p>这里我们思考一下，刚才我们Controller层代码中并没有检测target的合法性，但现在我们传入恶意的target又被拦截了，说明了什么？说明这个downloadbak请求到达Controller类代码之前被拦截并执行了检测，第一时间就想到了去看看Spring的配置文件中是否配置了拦截器</p><p><strong>2、interceptor层</strong></p><p>果不其然，在其中找到了这样一段Spring MVC的拦截器配置代码，如下</p><pre><code class="java">&lt;mvc:interceptors&gt;        // 第一个拦截器        &lt;mvc:interceptor&gt;            &lt;!-- 拦截所有的请求--&gt;            &lt;mvc:mapping path=&quot;/**&quot; /&gt;            &lt;bean class=&quot;cn.com.mjsoft.cms.common.interceptor.SpringMVCFlowExeTokenAndTraceInterceptor&quot; /&gt;        &lt;/mvc:interceptor&gt;        // 第二个拦截器        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=&quot;/survey/clientVote.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/guestbook/clientAddGb.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/content/clientAddContent.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/content/clientEditContent.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/content/deleteContentToTrash.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/clientAddComment/clientAddComment.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/deleteComment/deleteComment.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/resources/clientDf.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/member/*.do&quot; /&gt;            &lt;bean class=&quot;cn.com.mjsoft.cms.member.interceptor.MemberActScoreInterceptor&quot; /&gt;        &lt;/mvc:interceptor&gt;        // 第三个拦截器        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=&quot;/member/*.do&quot; /&gt;            &lt;bean class=&quot;cn.com.mjsoft.cms.member.interceptor.MemberSendMessageInterceptor&quot; /&gt;        &lt;/mvc:interceptor&gt;        // 第四个拦截器        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=&quot;/content/addContent.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/content/editContent.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/content/clientAddContent.do&quot; /&gt;            &lt;mvc:mapping path=&quot;/content/clientEditContent.do&quot; /&gt;            &lt;bean class=&quot;cn.com.mjsoft.cms.content.interceptor.DeleteTempFileWhenUploadErrorInterceptor&quot; /&gt;        &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p>可以看到配置了四个拦截器，这里能够匹配到&#x2F;resources&#x2F;donloadbak.do请求的只有第一个拦截器</p><p>这里提一下以下两种情况</p><p>1、如果有多个拦截器都能匹配，则拦截顺序默认按照配置拦截器的顺序进行</p><p>2、Spring MVC中，可以通过在配置文件中使用<a href="mvc:interceptor-ref">mvc:interceptor-ref</a>标签来引用并配置拦截器，并使用order属性来<strong>指定它们的顺序</strong>，这样的话拦截顺序则变为指定顺序</p><p>回到正题，经过上面的分析，我们的&#x2F;resources&#x2F;downloadbak.do请求会先被第一个拦截器处理，所以我们跟过去看看第一个拦截器类（即SpringMVCFlowExeTokenAndTraceInterceptor类）的内容，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702108927114-afde61d8-82de-4422-8566-9bdad883e5cb.png" alt="img"></p><p>可以看到这个类实现了Spring的<strong>HandlerInterceptor</strong>接口，用于拦截请求并执行一些前置和后置的处理，这里我们要分析它对拦截的请求的检测逻辑，所以主要分析前置处理代码，即preHandle方法</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702108955090-f66ef8df-8ae2-469b-8cdb-4fc24286b3b6.png" alt="img"></p><p>简单看了下preHandle方法，只是进行了权限校验，也没有对参数特殊字符的处理</p><p>Controller类中没有处理，Controller类之前的拦截器也没有处理，那还有什么能够在Controller类和拦截器之前对请求进行处理呢？答案就是<strong>过滤器（Filter）</strong></p><p><strong>3、Filter层</strong></p><p>过滤器的配置可以到Web应用的配置文件web.xml文件中查看，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702109362806-82457bfa-284b-4a70-b9bd-744af0d45f7d.png" alt="img"></p><p>可以看到这里配置了两个过滤器，第一个拦截的是所有请求，第二个拦截的是.do结尾的，我们刚才被拦截的请求是</p><pre><code class="plain">/sources/downloadbak</code></pre><p>所以会被第一个Filter拦截，我们定位到到第一个Filter对应的Filter实现类中，即InterceptFilter类</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702109777000-bacce3ae-9d45-4ba0-8554-ac84df002065.png" alt="img"></p><p>可以看到InterceptFilte类虽然名字叫InterceptFilte（拦截器），但其实实现的是Filter接口的一个自定义过滤器，因为刚才控制台打印了如下两句话</p><pre><code class="plain">[2023-12-09 15:54:27,756] FATAL  - danger char-&gt;..[2023-12-09 15:54:27,757] FATAL  - IP-&gt;172.24.86.134,非法动作-&gt;target=../a.txt&amp;pw=,URL-&gt;http://172.24.86.134:8090/resources/downloadBak.do</code></pre><p>说明是我们传入的<strong>target&#x3D;..&#x2F;a.txt</strong>中带了**”..”<strong>被识别为危险字符了，所以先搜索一下</strong>“..”**字符，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702109987824-7120c23f-6ddf-45bb-bc28-63aa875ea1d0.png" alt="img"></p><p>在静态代码块中成功找到定义，而且这个_$6的内容看着也像黑名单字符，所以我们先试着追踪一下_$6的流转</p><p>可以看到288行调用当前类的_$1方法时，将_$6作为参数传入了方法</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702110351122-bba808b7-2c92-4567-b006-a9fe1db95657.png" alt="img"></p><p>我们分析一下_$1方法，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702110504863-6a13ee02-bcaf-4902-8c2c-f4af8f02bb66.png" alt="img"></p><p>经过分析，发现确实就是它导致了我们的..被拦截，分析流程如下</p><pre><code class="java">private boolean _$1(String var1, String[] var2, String var3, boolean var4) &#123;    _$13.debug(&quot;&#123;SYSTEM Adjudgement&#125; 将验证参数:&quot; + var1);    // 判断var1是否为空，为空就退出    ......    //不为空就继续执行    if (var1.startsWith(&quot;http://&quot;)) &#123;        //如果URL以 &quot;http://...&quot; 开头，检查它是否与已知站点的URL匹配，或者是否包含特定危险字符。        //如果匹配或包含危险字符，记录错误日志，返回 false 表示不安全。     &#125;     // 如果var4=true         // 就检查var1是否包含危险字符         // 包含的话就打印错误信息并退出返回false     // 如果var4=false         // 就检查var1是否包含危险字符和“=”号         // 包含的话就打印错误信息并退出返回false    return true;    &#125;</code></pre><p>简单来说这段代码就是用于检测<strong>var1</strong>是否包含提前定义好的危险字</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702111573144-c770f032-905f-488c-a71d-017224413a20.png" alt="img"></p><p>所以刚才我们的控制台上会出现 **danger char-&gt;..**这个信息</p><p>因为刚才的判断代码返回false，即我们的输入不安全，所以这里的288内的代码块会被执行</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702111748498-4eb25ecf-5cb2-4dc2-bf42-5f937b489f56.png" alt="img"></p><p>导致var55被赋值为false，从而执行第299行代码，即调用_$1方法，_$1方法打印出本次导致错误的动作信息，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702111937697-07dc5fa1-a3e1-49e6-853d-f898f121a1c5.png" alt="img"></p><p>这也就解释了我们控制台的第二句打印</p><pre><code class="plain">IP-&gt;172.24.86.134,非法动作-&gt;target=../a.txt&amp;pw=,URL-&gt;http://172.24.86.134:8090/resources/downloadBak.do</code></pre><p>所以这个**&#x2F;downloadbak.do**下载接口是有特殊字符过滤的，我在这里试了很久，但还是没有办法绕过，即没有办法配合目录穿越 ..&#x2F; 来读取任意位置的敏感文件，所以我个人认为这里暂时是没有漏洞的。</p><p>进入下一个下载功能点。</p><h2 id="downloadresfile-do"><a href="#downloadresfile-do" class="headerlink" title="&#x2F;downloadresfile.do"></a>&#x2F;downloadresfile.do</h2><h3 id="1-功能点定位"><a href="#1-功能点定位" class="headerlink" title="(1)功能点定位"></a>(1)功能点定位</h3><p>首先定位到关键代码</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702123471633-bdbe4174-4dac-4063-974d-2246fb88254b.png" alt="img"></p><p>可以看到关键代码位于<strong>ManageSiteFileAndCheckController类</strong>中，再请求到定位该接口的jsp文件中，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702123601086-f71adc50-94f4-47cb-9c06-9df000cfee5c.png" alt="img"></p><p>成功定位到<strong>ManageTemplate.jsp</strong>文件中，并且还传入了一个<strong>entry参数</strong></p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702123752595-7999e0b7-f679-49d5-9eaa-5513211fdcd0.png" alt="img"></p><p>根据文件名和文件信息确认该功能点为模板管理功能的下载功能，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702123928520-d51948b7-2849-4d4a-a59e-fed610214b66.png" alt="img"></p><h3 id="2-源代码审计"><a href="#2-源代码审计" class="headerlink" title="(2)源代码审计"></a>(2)源代码审计</h3><p>根据上一个下载的功能点，我们知道了请求参数的值中<strong>不能包含指定的危险字符</strong>，基于这个前提，我们再来审计一下这个下载的功能点</p><p>审计上一个下载点的时候，我们已经把<strong>过滤器</strong>和<strong>拦截器</strong>分析过了，这里就不分析了，直接看Controller类的代码，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702124475363-4335c6e4-b1e6-4c1c-a684-383248bbdc72.png" alt="img"></p><ul><li>1、先分析211-219行，从请求中获取<strong>mode、entry、downFileInfo参数的值</strong>,并且entry和downFileInfo两个参数还经过了<strong>SystemSafeCharUtil.decodeFromWeb方法</strong>处理</li><li>2、校验用户身份是否合法</li><li>3、根据日期随机生成一串字符，拼接.zip，形成一个类似下面这样的<strong>压缩文件名</strong></li></ul><pre><code class="java">*sys_template_temp*demo_2023_465461.zip</code></pre><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702125918159-9707ab1a-f714-4dba-9d3b-9be12f0ff3df.png" alt="img"></p><p>发现在267行拼接了压缩文件名，跟进<strong>getFullPathByManager方法</strong>来到<strong>ResourcesService.java类</strong>中</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702126176790-bbc1ee0d-290a-47d1-96dc-48dc38bf0fd1.png" alt="img"></p><p>主要代码如上，简单来说该方法就是把zipName中的<em><strong>替换为路径分隔符（”&quot;或者”&#x2F;“）</strong>,再</em><em>过滤掉一些敏感字符</em><em>,再与根路径进行拼接，最终得到类似如下的*<em>fullZipPath</em></em></p><pre><code class="java">E:\WorkSpace\Javawork\JTopCMSV3-JTopCMSV3.0.2-OP\target\ROOT\demo\sys_template_temp\demo_2023_465461.zip\\ 其中*sys_template_temp*demo_2023_465461.zip为传入的zipName(entry)</code></pre><p>后面的代码简单的说就是<strong>基于根目录</strong>，压缩<strong>template（entry参数的值）</strong>文件夹下的<strong>block（downloadfileinfo参数的值）文件夹下的内容</strong>并复制到<strong>sys_template_temp目录</strong>下，同时<strong>供用户下载</strong></p><p>所以就从头梳理了一下，想起了最开始获取请求的<strong>entry、downFileInfo参数的值</strong>时，获取后调用了<strong>SystemSafeCharUtil.decodeFromWeb方法</strong>，所以我们追踪<strong>SystemSafeCharUtil.decodeFromWeb</strong>方法，如下</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702132136595-3b23f5c1-21d3-43a2-90be-8a7c51762a80.png" alt="img"></p><p>可以看到该方法将传入的input参数进行了一次<strong>url解码</strong>后，再调用<strong>decodeDangerChar()方法</strong>，我们继续追踪该方法</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702132301394-3e66d7bd-c7f3-473c-aaa6-3158523c894b.png" alt="img"></p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702132684863-ac793268-9558-48ea-901a-b91a0584fdc3.png" alt="img"></p><p>通过代码可以得知该方法主要用来完成替换危险字符的操作，如果路径中存在一些危险字符的话就会被该方法替换为指定字符，同时我观察到</p><ul><li><em><strong>*!4*</strong></em> 则会被替换成**”..”** </li><li><em><strong>*!11*</strong></em> 会被替换成**”\“**</li></ul><p>这样说的话路径中存在 ****!4****!11*<em><strong>的话就会变为</strong>“..\“</em>*,这样是不是就又可以向上遍历目录了？于是我们来尝试读取一下电脑上的其他文件，例如</p><pre><code class="plain">E:\info.txt</code></pre><p>经过我们上面的分析，得出下载的<strong>文件根目录</strong>在</p><pre><code class="plain">E:\WorkSpace\Javawork\JTopCMSV3-JTopCMSV3.0.2-OP\target\ROOT\demo</code></pre><p>根据传入的<strong>entry</strong>和<strong>downFileInfo</strong></p><p>最后构成</p><pre><code class="plain">E:\WorkSpace\Javawork\JTopCMSV3-JTopCMSV3.0.2-OP\target\ROOT\demo\&#123;entry&#125;\&#123;downFileInfo&#125;</code></pre><p>所以我们把downFileInfo修改为要读取的info.txt，entry也利用多个****!4****!11****穿越到E盘的根目录，</p><p>尝试形成如下的文件链接</p><pre><code class="plain">E:\WorkSpace\Javawork\JTopCMSV3-JTopCMSV3.0.2-OP\target\ROOT\demo\template\..\..\..\..\..\..\..\..\info.txt</code></pre><p>从而读取到</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702134147480-b923d454-26ee-4c45-8abe-3f481866ad3e.png" alt="img"></p><p>成功读取到目标文件</p><p><img src="/2023/12/10/JTopCMS%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/1702134288227-6a884ada-afb6-461f-bdca-fb4d0b26eac5.png" alt="img"></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>到这里，JTopCMS的下载功能的目录穿越漏洞就审计完毕，看到Power7089师傅在讲解目录漏洞时讲了这个CMS的下载功能存在任意文件下载漏，就想着试一试自己能不能找到，在第一个下载点的审计花了很久，因为一直没找到“..&#x2F;”是怎么被拦截下来的，并且找到拦截代码之后尝试绕过也试了很久，还是没绕过去，审计第二个就比较容易了，直接在Controller类中就跟踪到了问题代码，审计完之后再和Power7089师傅的审计过程比对一下，发现确实是恶意字符替换导致的问题，这里贴一下Power7089师傅审计该漏洞的文章链接</p><p><a href="https://power7089.github.io/2022/11/29/JavaWeb%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E6%88%98%E4%B9%8B%E9%85%8D%E5%90%88JtopCMS%E5%AE%9E%E6%88%98%E8%AE%B2%E8%A7%A3%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/">https://power7089.github.io/2022/11/29/JavaWeb代码审计实战之配合JtopCMS实战讲解目录穿越漏洞/</a></p><p>最后，真的想吐槽一下，开发人员添加这个替换恶意字符的操作的意义是什么？明明Filter中都已经做了很好的拦截操作了，比如第一个下载的功能点，全靠Filter拦截，第二个下载点非要多此一举，替换后的字符和Filter中拦截的字符有些都是重复的，替换的意义是什么，真有点没搞明白。</p>]]></content>
    
    
    <summary type="html">Java代码审计实战之JtopCMS目录穿越漏洞</summary>
    
    
    
    <category term="代码审计" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="目录穿越" scheme="http://example.com/tags/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/"/>
    
  </entry>
  
  <entry>
    <title>代码审计—RBAC权限管理系统</title>
    <link href="http://example.com/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-12-03T11:08:28.000Z</published>
    <updated>2023-12-21T15:53:47.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、项目部署"><a href="#一、项目部署" class="headerlink" title="一、项目部署"></a>一、项目部署</h1><h2 id="1、Java环境"><a href="#1、Java环境" class="headerlink" title="1、Java环境"></a>1、Java环境</h2><p>使用java1.8.0_301版本进行部署</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701440805218-08dc53e4-d911-44d4-8673-95093dde6b67.png" alt="img"></p><h2 id="2、Maven"><a href="#2、Maven" class="headerlink" title="2、Maven"></a>2、Maven</h2><p>使用IDEA内置的Maven</p><h2 id="3、Mysql环境部署"><a href="#3、Mysql环境部署" class="headerlink" title="3、Mysql环境部署"></a>3、Mysql环境部署</h2><p>使用老版本的phpstudy搭建</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701440823828-d54763e0-48c0-4337-93f8-1a5f2fc009b4.png" alt="img"></p><p>创建数据库并导入数据</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701440836535-0e3b6115-b189-4ef4-b667-c64f1dad5135.png" alt="img"></p><h2 id="4、项目搭建"><a href="#4、项目搭建" class="headerlink" title="4、项目搭建"></a>4、项目搭建</h2><p>导入项目到IDEA</p><p>修改数据库连接信息</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701440854843-b16395be-e07f-48d8-b921-840c53b4839f.png" alt="img"></p><h2 id="5、项目启动"><a href="#5、项目启动" class="headerlink" title="5、项目启动"></a>5、项目启动</h2><p>项目启动之后访问127.0.0.1:8088即可访问到如下的登录页面</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701440874490-d57143cd-98d1-4298-b39a-86215402373e.png" alt="img"></p><h1 id="二、组件漏洞审计"><a href="#二、组件漏洞审计" class="headerlink" title="二、组件漏洞审计"></a>二、组件漏洞审计</h1><p>本项目是基于Maven构建的。对于Maven项目，我们首先要从pom.xml文件开始审计引入的第三方组件的版本是否为漏洞版本，再进一步验证组件是否存在漏洞</p><table><thead><tr><th>组件名称</th><th>组件版本</th></tr></thead><tbody><tr><td>Sping boot</td><td>2.3.1</td></tr><tr><td>Spring security</td><td>5.3.3</td></tr><tr><td>actuator</td><td>2.31</td></tr><tr><td>fastjson</td><td>1.2.56</td></tr><tr><td>thymeleaf</td><td>3.0.11</td></tr><tr><td>mybatis</td><td>2.1.2</td></tr><tr><td>swagger2</td><td>2.9.2</td></tr><tr><td>druid</td><td>1.1.21</td></tr><tr><td>easy-captcha</td><td>1.6.2</td></tr><tr><td>oshi-core</td><td>4.4.2</td></tr><tr><td>pagehelper</td><td>1.2.13</td></tr><tr><td>hutool</td><td>5.1.4</td></tr></tbody></table><h2 id="1、Spring-boot"><a href="#1、Spring-boot" class="headerlink" title="1、Spring boot"></a>1、Spring boot</h2><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的创建、运行、调试、部署等。使用Spring Boot可以做到专注于Spring应用的开发，而无需过多关注XML的配置。</p><p>在网上检索了Spring boot框架的漏洞，只找到一个很老的，如下</p><ul><li>Spring Boot框架SPEL表达式注入漏洞（**&lt; v1.3.0**）</li></ul><p>本项目的<strong>Spring Boot版本为2.3.1</strong>,所以不存在该漏洞，暂时放弃</p><h2 id="2、Spring-security"><a href="#2、Spring-security" class="headerlink" title="2、Spring security"></a>2、Spring security</h2><p> Spring Security 是Spring家族中的一个安全管理框架。核心功能就就是认证与授权。</p><p>该项目的<strong>Spring security版本为5.3.3</strong>，在网上把Spring security的历史的认证绕过CVE检索了一下，发现该版本只受到一个漏洞影响</p><ul><li><strong>CVE-2022-22978 RegexRequestMatcher认证绕过漏洞</strong></li></ul><p>但是该漏洞需要使用到<strong>RegexRequestMatcher</strong>方法进行正则匹配，本次项目并没有用到，所以暂时放弃该组件漏洞的查找</p><h2 id="3、Actuator"><a href="#3、Actuator" class="headerlink" title="3、Actuator"></a>3、Actuator</h2><p>Spring Boot Actuator 是 Spring Boot 提供的用于监控和管理应用程序的模块。它提供了一组现成的端点，可以让我们方便地监控和管理应用程序。这些端点包括健康状况、性能指标、配置信息、日志等。通过这些端点，我们可以了解应用程序的运行状况，及时发现和解决问题，提高应用程序的可用性和可维护性。</p><p>actuator的漏洞主要是未授权访问漏洞</p><p><strong>组件端点位置如下</strong></p><ul><li>Spring Boot 1.x版本端点在根URL下注册 </li><li>Spring Boot 2.x版本端点移动到&#x2F;actuator&#x2F;路径</li></ul><p><strong>组件未授权情况如下</strong></p><ul><li>Spring Boot &lt; 1.5 默认未授权访问所有端点</li><li>Spring Boot &gt;&#x3D; 1.5 默认只允许访问&#x2F;health和&#x2F;info端点，但是此安全性通常被应用程序开发人员禁用。</li></ul><p>因为这里的版本是2.31，所以端点是&#x2F;actuator&#x2F;路径，并且<strong>默认是不能访问其他敏感端口的</strong>，Actuator提供了13个接口，如下</p><table><thead><tr><th>GET</th><th>&#x2F;auditevents</th><th>显示应用暴露的审计事件 (比如认证进入、订单失败)</th></tr></thead><tbody><tr><td>GET</td><td>&#x2F;beans</td><td>描述应用程序上下文里全部的 Bean，以及它们的关系</td></tr><tr><td>GET</td><td>&#x2F;conditions</td><td>就是 1.0 的 &#x2F;autoconfig ，提供一份自动配置生效的条件情况，记录哪些自动配置条件通过了，哪些没通过</td></tr><tr><td>GET</td><td>&#x2F;configprops</td><td>描述配置属性(包含默认值)如何注入Bean</td></tr><tr><td>GET</td><td>&#x2F;env</td><td>获取全部环境属性</td></tr><tr><td>GET</td><td>&#x2F;env&#x2F;{name}</td><td>根据名称获取特定的环境属性值</td></tr><tr><td>GET</td><td>&#x2F;flyway</td><td>提供一份 Flyway 数据库迁移信息</td></tr><tr><td>GET</td><td>&#x2F;liquidbase</td><td>显示Liquibase 数据库迁移的纤细信息</td></tr><tr><td>GET</td><td>&#x2F;health</td><td>报告应用程序的健康指标，这些值由 HealthIndicator 的实现类提供</td></tr><tr><td>GET</td><td>&#x2F;heapdump</td><td>dump 一份应用的 JVM 堆信息</td></tr><tr><td>GET</td><td>&#x2F;httptrace</td><td>显示HTTP足迹，最近100个HTTP request&#x2F;repsponse</td></tr><tr><td>GET</td><td>&#x2F;info</td><td>获取应用程序的定制信息，这些信息由info打头的属性提供</td></tr><tr><td>GET</td><td>&#x2F;logfile</td><td>返回log file中的内容(如果 logging.file 或者 logging.path 被设置)</td></tr><tr><td>GET</td><td>&#x2F;loggers</td><td>显示和修改配置的loggers</td></tr><tr><td>GET</td><td>&#x2F;metrics</td><td>报告各种应用程序度量信息，比如内存用量和HTTP请求计数</td></tr><tr><td>GET</td><td>&#x2F;metrics&#x2F;{name}</td><td>报告指定名称的应用程序度量值</td></tr><tr><td>GET</td><td>&#x2F;scheduledtasks</td><td>展示应用中的定时任务信息</td></tr><tr><td>GET</td><td>&#x2F;sessions</td><td>如果我们使用了 Spring Session 展示应用中的 HTTP sessions 信息</td></tr><tr><td>POST</td><td>&#x2F;shutdown</td><td>关闭应用程序，要求endpoints.shutdown.enabled设置为true</td></tr><tr><td>GET</td><td>&#x2F;mappings</td><td>描述全部的 URI路径，以及它们和控制器(包含Actuator端点)的映射关系</td></tr><tr><td>GET</td><td>&#x2F;threaddump</td><td>获取线程活动的快照</td></tr></tbody></table><p>此时我们就要去看看开发人员开启了哪些配置，如果没有配置的话就是默认的&#x2F;info和&#x2F;health端点了，也就没有什么危害</p><p>这里我们可以通过配置文件，即application.yml文件查看配置状态，直接全局搜索<strong>endpoints</strong>也可以查看，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701440895667-949ddf54-587c-4ca8-b6aa-e604e40843b6.png" alt="img"></p><p>可以看到确实在application.yml文件中</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701440900483-7907f21d-0aec-451e-804a-38ca5df3c501.png" alt="img"></p><p>经过观察发现开发人员修改了这个配置，主动开启了如下几个端点</p><ul><li>&#x2F;beans</li><li>&#x2F;env</li><li>&#x2F;metrics</li></ul><p>其中那么就可以初步判断这个位置存在未授权访问漏洞，等待之后验证</p><p><strong>拓展一下：</strong></p><p>这里include如果是下面这样的话，就是开启所有端口 </p><pre><code class="yaml"> include &quot;*&quot;</code></pre><p>这里说的2.0的路由是&#x2F;actuator&#x2F;，我在网上找了一下，其实这个也可以自定义，如下配置即可</p><pre><code class="yaml">management:endpoints: web:   base-path: /manage</code></pre><p>此时的路由就会变为&#x2F;manage，就可以防止一些黑盒层面的目录遍历查找出未授权访问。</p><h2 id="4、Fastjson"><a href="#4、Fastjson" class="headerlink" title="4、Fastjson"></a>4、Fastjson</h2><p>FastJson是阿里巴巴的的开源库，用于对JSON格式的数据进行解析和打包。能够支持将java bean序列化成JSON字符串，也能够将JSON字符串<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>成Java bean</p><p>这里的fastjson版本是  1.2.56，经过搜索，发现该版本存在反序列化漏洞，这里就要讲一下fastjson常见的两种处理JSON的方法</p><ul><li><code>JSON.toJSONString()</code>方法：可将对象转换成<code>JSON</code>字符串</li><li><code>JSON.parseObject()</code>方法：将<code>JSON</code>字符串转换成对象。</li></ul><p>Fastjson该版本的漏洞也正是这两个函数的使用导致的问题，所以全局搜索这两个函数，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701441100826-36aa091f-7ffb-4838-bb60-3983a8586e56.png" alt="img"></p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701441107333-60444809-3ac8-4f4b-8e6c-7dee00d2c934.png" alt="img"></p><p>但是并没有搜到，那这里说明什么呢？说明该项目虽然导入了Fastjson，但是没有使用，自然也就不存在对应的漏洞，所以放弃这个点</p><h2 id="5、thymeleaf"><a href="#5、thymeleaf" class="headerlink" title="5、thymeleaf"></a>5、thymeleaf</h2><p>thymeleaf这里的版本是3.0.11</p><h3 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h3><p>Thymeleaf 3.0.0 至 3.0.11 版本存在模板注入漏洞，具体的漏洞判断与利用可以看下面的文章</p><p><a href="https://blog.csdn.net/m0_71692682/article/details/130538310">https://blog.csdn.net/m0_71692682/article/details/130538310</a></p><p>但经过测试，这里并不存在模板注入，基本都使用了@ResponseBody注解</p><p>@ResponseBody 是一个Spring框架中的注解，它用于指示该方法的返回值应该直接写入HTTP响应正文ResponseBody中， 而不是<strong>通过视图解析器进行渲染</strong> 。使用 @ResponseBody 注解可以将方法返回值以JSON、XML等格式直接写入HTTP响应体中，常用于返回 RESTful API 接口的响应数据。</p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>Thymeleaf中 th:text 标签进行渲染的时候，默认对特殊字符进行了转义，而th:utext 不会将字符转 </p><p>义。也就是说使用了 th:utext 标签会出现XSS漏洞。</p><p>经过全局搜索，发现有两处使用了 th:text 标签。没有地方使用 th:utext 标签。所以基于Thymeleaf的XSS审计也暂时放弃</p><h2 id="6、Mybatis"><a href="#6、Mybatis" class="headerlink" title="6、Mybatis"></a>6、Mybatis</h2><p>mybatis是一款用于持久层的、轻量级的半自动化ORM框架，封装了所有jdbc操作以及设置查询参数和获取结果集的操作，支持自定义sql、存储过程和高级映射。</p><p>这里的mybatis的版本是<strong>2.1.2</strong>。经过查找，发现该版本存在一个<strong>远程代码执行漏洞CVE-2020-26945</strong></p><p>但是有三个条件</p><ul><li>用户启用了内置的二级缓存</li><li>用户未设置JEP-290过滤器</li><li>攻击者找到了一种修改私有Map字段条目的方法，即修改org.apache.ibatis.cache.impl.PerpetualCache.cache有效的缓存密钥</li></ul><p>利用条件不满足，放弃该漏洞的审计</p><h2 id="7、swagger2"><a href="#7、swagger2" class="headerlink" title="7、swagger2"></a>7、swagger2</h2><p>Swagger 是一个开源的 API 设计和文档工具，它可以帮助开发人员更快、更简单地设计、构建、文档化和测试 RESTful API。Swagger 可以自动生成交互式 API 文档、客户端 SDK、服务器 stub 代码等，从而使开发人员更加容易地开发、测试和部署 API。</p><p>swagger的漏洞主要还是一个未授权访问漏洞</p><p>因为这个项目用的是SpringSecurity，所以我们可以去Springsecurity的配置文件——SpringSecurityConfig中看看是否对swagger做了权限校验</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701441166666-78b23132-7ebd-4156-b4cc-a885d4b84051.png" alt="img"></p><p>可以看到它这里直接放行了swagger的页面，所以判断这里也是存在未授权访问漏洞的</p><h2 id="8、Druid漏洞审计"><a href="#8、Druid漏洞审计" class="headerlink" title="8、Druid漏洞审计"></a>8、Druid漏洞审计</h2><p>Druid是阿里巴巴数据库出品的，为监控而生的数据库连接池，并且Druid提供的监控功能，监控SQL的执行时间、监控Web URI的请求、Session监控，首先Druid是不存在什么漏洞的。但当开发者配置不当时就可能造成未授权访问。</p><p>它存在的漏洞网上大致可以找到<strong>未授权访问</strong>和<strong>密码可爆破</strong>两个点</p><h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><p>这里的druid版本为1.1.21，经过网上的搜索，发现只有一个未授权漏洞，并且这个未授权漏洞是因为<strong>程序员的错误配置</strong>导致的，而不是druid本身的漏洞</p><p>Alibaba <a href="https://so.csdn.net/so/search?q=Druid&spm=1001.2101.3001.7020">Druid</a> 默认情况下未设置访问控制，攻击者可以登录以获取敏感信息。这里有两种情况可以防止这个未授权访问漏洞</p><ul><li>设置StatViewServlet(监控页面)的enabled为 <strong>false</strong>，即不启动监控页面</li><li>或设置监控页面的账密</li></ul><p>先查看是否存在这个未授权访问漏洞</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701441189600-f30b000c-ed72-46b5-9f52-e139657018cf.png" alt="img"></p><p>发现这里虽然开启了监控页面，但是设置了账密，所以并不存在未授权访问漏洞</p><h3 id="密码可爆破"><a href="#密码可爆破" class="headerlink" title="密码可爆破"></a>密码可爆破</h3><p>但是发现这个账密很简单，所以这里存在爆破的可能性，于是我去搜索了一下druid有没有f防爆破的措施，结果发现druid<strong>默认的登录页面是不需要验证码</strong>并且没有防爆破机制的，但有些程序员会自定义开发这个登录页面，添加爆破规则</p><p>我们通过查看resource下的static中的静态文件login.html，发现与默认页面相同，判断此处没有二次开发，即存在密码可爆破漏洞</p><h2 id="9、easy-captcha"><a href="#9、easy-captcha" class="headerlink" title="9、easy-captcha"></a>9、easy-captcha</h2><p>一款好用的Java图形验证码，支持gif、中文、算术等类型，可用于Java Web、<a href="https://so.csdn.net/so/search?q=JavaSE&spm=1001.2101.3001.7020">JavaSE</a>等项目。</p><p>但在网上并没有找到这个组件的公开漏洞，暂时放弃</p><h2 id="10、oshi"><a href="#10、oshi" class="headerlink" title="10、oshi"></a>10、oshi</h2><p>oshi-core 4.4.2</p><p>暂无漏洞</p><h2 id="11、Pagehelper"><a href="#11、Pagehelper" class="headerlink" title="11、Pagehelper"></a>11、Pagehelper</h2><p>去网上搜了一下，只发现了一个,cve-2022-28111(SQL注入漏洞)</p><p><a href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a>-PageHelper是一款分页插件。<br>Mybatis-PageHelper 1.x.x版本至5.x.x版本存在安全漏洞，该漏洞源于通过orderBy参数存在SQL注入漏洞。</p><p>但是经过搜索，该项目中<strong>并没有自定义orderBy参数进行排序</strong>，所以不存在该漏洞，这个点暂时忽略</p><h2 id="12、hutool"><a href="#12、hutool" class="headerlink" title="12、hutool"></a>12、hutool</h2><p>版本为5.1.4，找到了几个公开漏洞，整理如下</p><table><thead><tr><th>C<a href="https://avd.aliyun.com/detail?id=AVD-2023-42278">VE-2023-42278</a></th><th>Hutool JSONUtil.parse()缓冲区溢出</th><th>v5.8.21</th></tr></thead><tbody><tr><td>CVE<a href="https://avd.aliyun.com/detail?id=AVD-2023-42277">-2023-42277</a></td><td>Hutool  jsonObject.putByPath缓存区溢出</td><td>v5.8.21</td></tr><tr><td>CVE<a href="https://avd.aliyun.com/detail?id=AVD-2023-42276">-2023-42276</a></td><td>Hutool jsonArray缓存区溢出</td><td>v5.8.21</td></tr><tr><td>CVE<a href="https://avd.aliyun.com/detail?id=AVD-2023-3276">-2023-3276</a></td><td>HuTool SAXParserFactory XML外部实体注入漏洞</td><td>&lt; 5.8.19</td></tr><tr><td>CVE<a href="https://avd.aliyun.com/detail?id=AVD-2023-33695">-2023-33695</a></td><td>Hutool createTempFile函数敏感信息泄漏漏洞</td><td>&lt; 5.8.19</td></tr><tr><td><a href="https://avd.aliyun.com/detail?id=AVD-2022-4565">CVE-2022-4565</a></td><td>Hutool unzip 拒绝服务漏洞</td><td>4.4.2 ~ 5.8.10</td></tr><tr><td><a href="https://avd.aliyun.com/detail?id=AVD-2022-45690">CVE-2022-45690</a></td><td>Hutool JSONTokener 拒绝服务漏洞</td><td>&lt; 5.8.10</td></tr><tr><td><a href="https://avd.aliyun.com/detail?id=AVD-2022-45689">CVE-2022-45689</a></td><td>Hutool JSONObject   拒绝服务漏洞</td><td>&lt; 5.8.10</td></tr><tr><td><a href="https://avd.aliyun.com/detail?id=AVD-2022-45688">CVE-2022-45688</a></td><td>Hutool toJSONObject 拒绝服务漏洞</td><td>5.8.10</td></tr><tr><td><a href="https://avd.aliyun.com/detail?id=AVD-2022-22885">CVE-2022-22885</a></td><td>hutool HostnameVerifier 证书验证不恰当</td><td>&lt; 5.7.19</td></tr><tr><td><a href="https://avd.aliyun.com/detail?id=AVD-2018-17297">CVE-2018-17297</a></td><td>hutool unzip目录遍历任意文件写入漏洞</td><td>&lt; 4.1.12</td></tr></tbody></table><p>经过测试，发现符合条件的就是Hutool JSONObject   拒绝服务漏洞，因为版本符合，并且该项目也使用了该方法</p><p><a href="https://github.com/dromara/hutool/issues/2747">https://github.com/dromara/hutool/issues/2747</a></p><p>但由于项目使用了全局异常，所以并不能触发该漏洞，结束该漏洞的审计</p><h1 id="三、单点漏洞审计"><a href="#三、单点漏洞审计" class="headerlink" title="三、单点漏洞审计"></a>三、单点漏洞审计</h1><h2 id="1、SQL注入漏洞审计"><a href="#1、SQL注入漏洞审计" class="headerlink" title="1、SQL注入漏洞审计"></a>1、SQL注入漏洞审计</h2><p>本项目使用了Mybatis，来定义SQL。我们主要查看Myabatis中Mapper文件中是否存在使用 $ 拼接SQL语句的情况。使用 $ 是直接拼接SQL语句的，未进行转义。如下<img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701516823165-3fb08a64-130d-4588-99a9-4ce34ccd541c.png" alt="img"></p><p>先看看UserMapper文件</p><p>可以看到下面的第13行和第16行都使用了$拼接变量，都有可能存在问题，我们挨个分析<img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701518888829-7a0d7ccf-9989-4a15-90b5-223a299d0f5c.png" alt="img"></p><h3 id="1-1、nickName参数like注入"><a href="#1-1、nickName参数like注入" class="headerlink" title="1.1、nickName参数like注入"></a>1.1、nickName参数like注入</h3><p>首先分析上面的UserMapper文件的第13行，向上查看根据 select语句的id值追踪该dao层的代码文件。如果在IDEA中安装插件 Free Mybatis plugin 是可以快速进行跳转到代码文件，只需点击左侧绿色箭头即可</p><p>点击之后来到UserDao类，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701519317435-550fc90f-6bd4-4998-a07d-ba5807a7f121.png" alt="img"></p><p>可以看到getFuzzyUserByPage这个select语句的参数是一个MyUser实体类，再查看这个实体类，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701519639499-fa3bf668-7f08-4af0-9b23-b2abb3f48265.png" alt="img"></p><p>可以看到存在nickName和userName参数，即刚才我们发现的两个问题参数</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701519837853-50806f24-4366-4e71-9726-b060b0e7c1c6.png" alt="img"></p><p>继续向上追溯，发现UserServiceImpl类使用了这个方法，定位到45行，我们点进去看看，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701520021625-64219e93-1945-4ccc-b730-03d3d80e1e4b.png" alt="img"></p><p>发现该方法的使用位于getAllUserByPage方法内，并且参数来自于getAllUserByPage方法传入的参数，所以我们再去看看getAllUserBypage方法在哪个位置使用的，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701520198308-c48ca5b2-92f4-4a81-a071-4af4176a5acb.png" alt="img"></p><p>可以发现直接来到的Controller类中，并且根据这里的几个注解我们可以得出</p><ul><li>该方法对应的功能点为”查询用户”</li><li>该功能只有拥有”user:list”权限的用户才能使用</li><li>该接口在swagger文档中位于“用户列表”中</li></ul><p>再看看这里调用的getAllUserByPage方法传入的myUser参数从哪里来的，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701521034455-2749e4d2-4d94-4427-bf7c-582256584c14.png" alt="img"></p><p>观察到UserController类被映射到了&#x2F;api&#x2F;user接口</p><p>所以这里只要用户请求&#x2F;api&#x2F;user接口并带上MyUser实体类存在的参数，就会自动将该参数的值赋值给实体类new出来的对象myUser</p><p>即我请求127.0.0.1:8080&#x2F;api&#x2F;user?username&#x3D;1时，这里的myUser对象的username会被赋值为1，所以我们请求&#x2F;api&#x2F;user传入的nickName参数的值就会被带入问题SQL语句拼接并执行，造成SQL注入</p><p>整个流程串下来，确定了漏洞点为 nickName 参数，该参数值来源于查询用户功能 。</p><h3 id="1-2、userName参数like注入"><a href="#1-2、userName参数like注入" class="headerlink" title="1.2、userName参数like注入"></a>1.2、userName参数like注入</h3><p>这个注入同上，位于一个mapper，一个sql语句中，这里就略过了，后面的验证会一同验证</p><h3 id="1-3、dictName参数like注入"><a href="#1-3、dictName参数like注入" class="headerlink" title="1.3、dictName参数like注入"></a>1.3、dictName参数like注入</h3><p>同上</p><p>追踪到实现类，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703149648177-012c9604-7d2a-437f-89b6-ffb8df913a68.png" alt="img"></p><p>可以看到在实现类的<strong>updateParentDeptStatus</strong>方法调用了<strong>updateDeptStatus</strong>方法，我们再追踪到调用<strong>updateParentDeptStatus</strong>方法的位置，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703150164512-b410e7f9-704b-4d9b-ae7a-1f92c3b54de8.png" alt="img"></p><p>看到是实现类的<strong>updateDept</strong>方法调用了<strong>updateParentDeptStatus</strong>方法，继续追踪，来到Controller层</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703150351333-0192cf99-4f28-4587-ae0f-71bea90372a9.png" alt="img"></p><p>可以看到Controller层代码处理了传入的Mydept对象，处理的过程中调用<strong>updateDept</strong>方法</p><p>同时Mydept实体类代码如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703150511937-160cdf9a-8b58-440a-adf1-7920117a2a60.png" alt="img"></p><p>现在我们理一下上面的输入流转过程，如下</p><ul><li>1、用户输入，传入Mydept对象,命名为为dept</li><li>2、Controller层调用updateDept(dept)</li><li>3、updateDept方法调用updateParentDeptStatus(dept)</li><li>4、updateParentDeptStatus方法调用了updateDeptStatus(dept)</li><li>5、进入DeptDao</li><li>6、Mabatis获取传入的Dept实例的ancestors属性值，并执行对应的update语句</li></ul><p>咋一看是不是一个很简单的注入，但是仔细看看第四步的代码，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703151419832-34b4b82d-4f5e-4fbd-a978-9d935f895ac7.png" alt="img"></p><p>获取传入的dept实例的dept_id属性值，并根据这个id值从数据库获取对应的dept实例，再将数据库获取的dept赋值为dept，即覆盖了传入的dept实例</p><p>那这里被覆盖之后的dept的ancestors属性值还会是我传入的dept属性值吗？当然就不是了，而是根据传入的id值从数据库中取出来的</p><p>说明了什么？说明针对这个输入流转，我们的ancestors值是不可控的，为什么是“针对这个输入流转呢”？</p><p>这里就引出一个平时审计SQL注入漏洞时需要注意的点了，当某个存在SQL注入的参数在当前输入流转不可控时，可以找找其他地方，看能否通过其他功能修改该参数，从而使该参数可控</p><p>那怎么找呢？找能够控制该参数的对应方法即可，例如这里参数不可控的原因是因为参数是从数据库取出来的，那我们就可以找找什么地方可以修改数据库中的这个值，即在对应的mapper文件中找找insert语句和update语句</p><p>这里共有三个update语句，并没有insert，所以下面我们来逐个看看这三个update语句</p><h4 id="1-4-1、第一个update"><a href="#1-4-1、第一个update" class="headerlink" title="1.4.1、第一个update"></a>1.4.1、第一个update</h4><p>第一个update语句如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703162908062-33aa35b5-53f6-4720-9f6e-e9ba6b84d285.png" alt="img"></p><p>可以看到这个update语句的作用就是设置指定id的部门的ancestors为指定值<img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703165619006-15f34324-0f05-4a2c-9ac1-e60f3442e2cb.png" alt="img"></p><p>经过追踪，发现该方法传入的ancestors只能是如下</p><pre><code class="java">String newAncestors = parentInfo.getAncestors() + &quot;,&quot; + parentInfo.getDeptId();即&#123;上级部门ancestors,上级部门id&#125;</code></pre><p>显然我们要控制此处的ancestors为恶意payload是不可能的（因为部门id我们是不可控的），所以这个点放弃</p><h4 id="1-4-2、第二个update"><a href="#1-4-2、第二个update" class="headerlink" title="1.4.2、第二个update"></a>1.4.2、第二个update</h4><p>第二个update语句如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703166128324-365f722b-4c0c-4cd8-866b-3da4aeb94dbf.png" alt="img"></p><p>将数据库中指定id的dept信息换为传入的dept信息，其中就包含了ancestors参数，所以只要我们能够控制传入dept实例的ancestors属性值，就能够修改数据库中对应的ancestors，造成SQL注入漏洞</p><p>所以我们向上追踪一下，先来到Dao层，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703166387564-3a645225-6f3b-40f2-9905-f74d99fcf2b3.png" alt="img"></p><p>来到实现类<img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703166970724-fa8268af-aebe-4a57-baf6-4d9dbeb205df.png" alt="img"></p><p>可以看到实现类中，传入的dept对象如果<strong>有上级部门</strong>，并且<strong>当前dept对象不为空</strong>，就会进入到if判断逻辑内部，这里if判断逻辑我们再分析第一个update时也分析过了，会修改我们传入的dept对象的ancestors属性值</p><p>如果我们想要插入恶意ancestors，自然就不能让程序修改我们输入的ancestors属性值，也就是不进入这个if判断逻辑，我们传入的dept对象因为要带有恶意ancestors参数值，所以也肯定不会为空，所以我们要尽量保证我们传入的dept对象没有上级部门，这样就不会进入if内部导致输入的ancestors被程序修改</p><p>之后程序就会调用updateDept直接替换dept对象的信息到数据库中，我们继续向上追踪，来到Controller层</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703166737237-415d77e5-e787-4c18-be41-ff25fb46eae4.png" alt="img"></p><p>可以看到Dept对象来源于用户的请求，经过一系列逻辑判断，再调用实现类，所以我们请求该Controller方法映射的接口时，带上ancestors参数即可。并且通过观察该方法的注解，发现该方法对应程序中的“修改部门”功能</p><p>所以经过上面的分析，我们确定这个位置是可以控制数据库中的ancestors值的，只需要在“修改部门”的请求中带上ancestors参数，并且当前部门没有上级部门，我们输入的ancestors就会覆盖数据库中ancestors参数值，即实现了ancestors参数可控</p><p>又因为刚才我们发现的SQL语句使用$拼接了ancestors参数的值，并且ancestors参数的值是从数据库中获取的</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703167629649-3ea977f4-18b7-4459-8bd2-01853ce37d5e.png" alt="img"></p><p>所以判断此处存在SQL注入漏洞，等待验证</p><h4 id="1-4-3、第三个update"><a href="#1-4-3、第三个update" class="headerlink" title="1.4.3、第三个update"></a>1.4.3、第三个update</h4><p>第三处update语句如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703167683917-d6e3e257-29a0-41fa-997c-634c52d4fa6b.png" alt="img"></p><p>这个update语句根本没涉及到ancestors参数，所以无需分析</p><h3 id="1-5、params-dataScope参数注入"><a href="#1-5、params-dataScope参数注入" class="headerlink" title="1.5、params.dataScope参数注入"></a>1.5、params.dataScope参数注入</h3><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703167935532-ea22f6c9-c651-4b6b-90b4-a5ae43f9882b.png" alt="img"></p><p>这个就不用多说，总共四处，直接传入params[dataScope]为恶意语句即可</p><h2 id="2、XSS漏洞审计"><a href="#2、XSS漏洞审计" class="headerlink" title="2、XSS漏洞审计"></a>2、XSS漏洞审计</h2><p>熟悉代码后快速<strong>全局搜索是否存在”XSS”，”xssfilter”,以及是否含有常见的对JS标签进行黑名单过滤的工具</strong>，如果没有，那大概率是没有进行XSS漏洞的防御的</p><p>经过检索，没有发现该项目存在XSS的防御代码，所以大概率是全站XSS，随意验证几个，如下</p><ul><li>新增&#x2F;编辑用户</li><li>新增&#x2F;编辑角色</li><li>新增&#x2F;编辑菜单</li><li>新增&#x2F;编辑部门</li><li>新增&#x2F;编辑岗位</li><li>新增&#x2F;编辑字典</li><li>日志记录功能造成的“操作日志”</li></ul><h3 id="2-1、layui框架"><a href="#2-1、layui框架" class="headerlink" title="2.1、layui框架"></a>2.1、layui框架</h3><p>并且在测试XSS的时候还发现了前端框架为layui，所以针对Layui再进行研究，如下</p><p>全局搜索layui-v，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701566877104-e1d3896f-125b-4556-9fea-81353b5fab88.png" alt="img"></p><p>得到Layui的版本为5.2.6</p><p>在网上并没有检索到layui框架有关xss的问题，师傅分享的Layui的Github上的issue已经被删除</p><p><a href="https://github.com/sentsin/layui/issues/711">https://github.com/sentsin/layui/issues/711</a></p><p>所以去找了找，发现”疯癫兄”师傅提交的rbac审计作业中截了issue的图，所以能了解到该漏洞的详情，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701567170788-d31f2ff2-9107-40c9-9d6b-59ce63b45bf6.png" alt="img"></p><p>通过上面的issue得到以下结论</p><ul><li><strong>1、</strong>Layui的2.6.8版本之前Table组件默认不转义HTML，需要转义的话要手动在所有的列定义中加上如下代码</li></ul><pre><code>templet:&quot;&#123;&#123;= d.field &#125;&#125;&quot;</code></pre><ul><li><strong>2、</strong>2.6.8版本之后增加了escape参数，通过配置该参数为true即可对xss相关字符进行过滤</li><li><strong>3、</strong>2.6.11版本默认table的escape参数为true，即默认开启编码</li></ul><p>因为太久没用过layui了，所以对table组件也比较陌生，所以这里查看官方文档简单学习了一下，官方文档链接如下</p><p><a href="https://layui.dev/docs/2/table/">https://layui.dev/docs/2/table/</a></p><p>Layui的table模块提供的三种渲染方式——方法渲染、自动渲染和静态表格，各有特点，（有兴趣的可以看官方文档学习一下）</p><p>我简单整理了一下如何快速查看当前项目用的table模块是哪种渲染方式，都没有的话就是没有用table模块</p><ol><li><strong>方法渲染</strong>：搜索JavaScript文件中的“table.render”或“layui.table.render”等关键字。</li><li><strong>自动渲染</strong>：在HTML文件中搜索包含“layui-table”类名的table标签，并检查是否含有“lay-data”属性。</li><li><strong>静态表格</strong>：在HTML文件中搜索包含“layui-table”类名的table标签，但不包含JavaScript代码或“lay-data”属性。</li></ol><p>通过检索，发现js文件中存在”table.render”关键字</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701568344128-221878f3-1f20-47bc-ba2a-fb62ebc3fac8.png" alt="img"></p><p>所以此处使用了”方法渲染”，来到该位置</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701568865907-37c03dbd-08a2-4e53-9ab2-4228c5534349.png" alt="img"></p><p>通过注释和对代码的分析，发现该功能用于渲染表格的数据内容，又由刚才的issue可知，这里的渲染是默认不编码，所以默认存在XSS漏洞，才会造成前面我们测试XSS时有表格的地方基本都存在XSS漏洞的情况</p><h2 id="3、业务逻辑漏洞"><a href="#3、业务逻辑漏洞" class="headerlink" title="3、业务逻辑漏洞"></a>3、业务逻辑漏洞</h2><p>（1）<strong>先看权限控制</strong></p><p>观察是否动态使用了五张表完成了权限与用户，角色的动态绑定，并正确配置</p><ul><li>用户表（my_user）</li><li>角色表（my_role）</li><li>权限表（my_menu）</li><li>用户角色关联表（my_role_user）</li><li>角色权限关联表（my_role_menu）</li></ul><p>可以从数据库中观察到确实使用了对应的五张表</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701570808854-b5a28a99-5c8b-495b-8028-edda51f70cf2.png" alt="img"></p><p>通过对照权限表和角色权限关联表判断开发人员设置的权限是否有不合理的地方</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701586228000-7a28cc56-6952-4a20-82a5-b89ad9bf353a.png" alt="img"></p><p>发现开发人员默认给了普通用户删除用户的权限，我们验证一下管理员账户是否有权限配置功能</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701587128610-995346dd-41e1-4f2d-af75-ea0cff8af9ee.png" alt="img"></p><p>可以看到开发人员是默认给了普通用户对用户增删改的操作的</p><p>我们登录一个普通用户后台看看，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701586818454-4bab4c67-f6a8-43e3-b23d-df8500aa58dd.png" alt="img"></p><p>发现普通用户登录并看不到其他用户，但是又有对其他用户的操作权限，所以这里存在替换cookie或者改ID来越权操作其他用户</p><p>归结原因就是因为管理员默认开启普通用户的操作权限，关闭之后就不会有该问题</p><p>注意：我看其他师傅审这个系统时，从代码层面开始，例如</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701588012350-ca30d3dd-cd45-4c2d-93eb-55bf230d2eb3.png" alt="img"></p><p>这里是有问题的，这里使用了@PreAuthorize(“hasAnyAuthority(‘user:del’)”)进行权限关联，限定拥有user:del权限的用户才能发起这个请求，如果用户没有 ‘user:del’ 这个权限，Spring Security会拒绝这个请求，不会执行这个方法。，所以这里的代码层面是没有问题的，有问题的只是管理员的错误配置。</p><p>（2）看是否使用了成熟的权限校验框架</p><p>这里的权限校验框架一般就是Spring security或者shiro</p><p>经过前面分析pom文件时观察导入的依赖，得出了该项目是使用了Spring security组件配合jwt来实现动态权限校验的,所以观察SpringSecurityConfig类，这就是Spring security的配置文件，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701571410922-f46638bf-b64c-46bd-84b0-70753cf94f4a.png" alt="img"></p><p>可以看到放行的静态资源中有很多敏感的接口，这就属于配置错误了，所以这里存在接口未授权访问漏洞</p><p>（3）看数据是如何鉴权的</p><ul><li>分析详细的api和业务系统——看数据是否公开，公开就忽略</li><li>看各自的数据获取是否合理——对于私有的数据，<strong>是否校验了当前用户登录的身份</strong></li></ul><h2 id="4、图形验证码"><a href="#4、图形验证码" class="headerlink" title="4、图形验证码"></a>4、图形验证码</h2><p>全局搜索关键字captcha，寻找相关代码，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701572554421-9c30cba3-68ff-4697-9ffe-95ed94920728.png" alt="img"></p><p>经过检索，发现图形验证码的验证逻辑位于VerifyCodeFilter这个Filter类中</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701572622178-4009504c-a6cb-4833-affb-76e3babafc75.png" alt="img"></p><p>此时就需要我我们来分析一下这个代码逻辑了，经过分析之后简单的流程ruxa</p><ul><li>检查请求方法是否为 “POST”，并且请求的URL是否为 “&#x2F;login”。</li><li>从请求中获取会话（session）。</li><li>获取用户提供的验证码（captcha）以及会话中生成的验证码。</li><li>处理用户提供的验证码为空的情况。如果为空，从会话中删除验证码并返回一个包含错误信息的 JSON 响应。</li><li>如果不存在验证码为空的情况，就直接chain.doFilter(request, response)放行了该请求</li></ul><p>注意：这里观察到注释内容为判断验证码是否过期和用户输入的验证码与生成的验证码是否匹配，但是这两个判断均被注释了，所以导致即使验证码过期或验证码错误也不会被拦截，即只要验证码不为空就能通过验证码校验机制，猜测是开发人员为了开发方便注释了该代码，但项目上线之后未取消注释，从而造成了验证码绕过漏洞</p><h1 id="四、漏洞验证"><a href="#四、漏洞验证" class="headerlink" title="四、漏洞验证"></a>四、漏洞验证</h1><h2 id="1、Actuator未授权访问漏洞"><a href="#1、Actuator未授权访问漏洞" class="headerlink" title="1、Actuator未授权访问漏洞"></a>1、Actuator未授权访问漏洞</h2><p>直接扫Spring的目录，结果如下（这里使用的工具是Caesar）</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701590889965-ba569584-3165-4d08-9748-679e6da7cffb.png" alt="img"></p><p>其中env包含了了全部环境属性，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701591175366-30616dd6-dfec-42c6-a046-7bb911d3171e.png" alt="img"></p><p>搜索（<em>），可以看到被星号脱敏的密码，观察其与spring.datasource.password对应，应该是数据库的密码，如果这里&#x2F;heapdump端点也开放的话，就可以尝试访问</em>*&#x2F;actuator&#x2F;heapdump**来获取明文密码。但刚才我们查看配置文件时，显示是没有开放&#x2F;heapdump，也就无法更深层次的利用</p><p>即这里Actuator的未授权漏洞造成的危害仅限于以下三个端点开放造成的信息泄露</p><ul><li>&#x2F;beans</li><li>&#x2F;env</li><li>&#x2F;metrics</li></ul><h2 id="2、swagger未授权访问漏洞"><a href="#2、swagger未授权访问漏洞" class="headerlink" title="2、swagger未授权访问漏洞"></a>2、swagger未授权访问漏洞</h2><p>访问&#x2F;swagger-ui.html</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701595993806-f00c1ea9-dd18-43e6-b52e-5e0c8027b365.png" alt="img"></p><p>使用swagger工具快速测试，工具链接如下</p><p><a href="https://github.com/jayus0821/swagger-hack">https://github.com/jayus0821/swagger-hack</a></p><p>并未发现存在问题的接口，所以这里也就无法进行深度利用，所以此处仅存在swagger接口文档泄露，即Swagger未授权访问漏洞</p><h2 id="3、Druid密码可爆破漏洞（无危害）"><a href="#3、Druid密码可爆破漏洞（无危害）" class="headerlink" title="3、Druid密码可爆破漏洞（无危害）"></a>3、Druid密码可爆破漏洞（无危害）</h2><p>上面我们审计了Druid的未授权访问漏洞不存在，但是存在密码可爆破漏洞，所以这里我们来验证一下，访问&#x2F;druid接口，如下</p><p>但这里发现了一个问题，<strong>这个密码可爆破漏洞并不能算一个漏洞</strong>，因为此处开发人员并没有把druid公开，而是只允许本地访问(也就是127.0.0.1)，其他IP访问时，会被拦截，页面如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701597619548-5b3c2675-6a12-44f4-b5d0-1c702b048cfe.png" alt="img"></p><p>再来看看druid的配置，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701597454258-8f3c02e0-9fb4-493d-a886-0904d38e5382.png" alt="img"></p><p>查了一下，其实druid默认是不公开的，需要添加allow：才会允许所有主机访问，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701597336196-e54b0faa-22e6-4fb7-a567-267e513d5b82.png" alt="img"></p><p>此时其他主机访问到这个druid才会展示登录页面</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701597744975-43ef9cf7-65fd-4910-8d5a-9db3c6a7baa8.png" alt="img"></p><p>爆破的过程就不讲了，就burp账户设置为admin,跑密码字典,根据回显长度判断正确的密码，前面师傅的文章有截图，可以去看看</p><h2 id="4、SQL注入漏洞"><a href="#4、SQL注入漏洞" class="headerlink" title="4、SQL注入漏洞"></a>4、SQL注入漏洞</h2><p>经过上面的SQL审计，我们发现了8个SQL注入漏洞，这里就简单验证三个，其他的师傅们自己下去验证即可</p><p>来到用户查询页面</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701598946590-3092aa2f-0e4f-47bb-a288-0c9124f809d8.png" alt="img"></p><p>开启，burp。任意输入之后点击查询，再把这个包丢给Sqlmap即可</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701598873770-c949578a-04f6-4f2b-86d4-2ae3065f80c2.png" alt="img"></p><p>可以看到成功跑出了数据库列表</p><p>第二个就是参数注入</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703171771203-bee35db9-2b76-44a4-b61e-8a9d6f4aae57.png" alt="image.png"></p><p>第三个就是params[datasCope]参数注入</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1703173805014-a8d7ed2c-669e-42df-b18d-f54d41698532-1703173863736-31.png" alt="image.png"></p><h2 id="5、XSS漏洞"><a href="#5、XSS漏洞" class="headerlink" title="5、XSS漏洞"></a>5、XSS漏洞</h2><p>这个就更多了，上面审计的时候我也说了哪些地方存在XSS，这里也是验证一个即可</p><p>任意找一个表格功能的增加或编辑功能，添加payload</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701599217840-19575126-189c-475e-b52a-b1ecc44ad9f3.png" alt="img"></p><p>提交保存即可成功弹窗</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701599268735-f68fca15-349b-4a3d-97a1-407fc4bdac9c.png" alt="img"></p><h2 id="6、业务逻辑漏洞"><a href="#6、业务逻辑漏洞" class="headerlink" title="6、业务逻辑漏洞"></a>6、业务逻辑漏洞</h2><p>上面我们审计到了因为管理员的错误配置导致普通用户可以越权删除其他用户，下面来验证一下</p><p>登录test这个普通用户，来到用户管理页面</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701599859314-f33a4097-6bb0-4bc5-b279-1e33ed3fc1a9.png" alt="img"></p><p>可以看到只能看到和操作test6用户</p><p>此时开启burp，点击删除用户，抓到如下数据包</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701599933636-2e5bd0a3-a887-4cbd-b95b-1202ef2532de.png" alt="img"></p><p>查看数据库发现修改的是id为8的用户</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701599963946-c78bb421-cb80-4d1a-bdda-0ddf1b56db9b.png" alt="img"></p><p>此时把8改为5，尝试删除“封禁用户”</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701600005372-139aa7a9-89c1-4382-be55-ab8cd340250f.png" alt="img"></p><p>删除成功，来到数据库检查</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701600033133-3f094b5b-3524-491d-ab1d-a8aaee94a10a.png" alt="img"></p><p>可以看到”封禁用户”已经被越权删除了，即存在<strong>越权删除用户漏洞</strong></p><h2 id="7、图形验证码失效漏洞"><a href="#7、图形验证码失效漏洞" class="headerlink" title="7、图形验证码失效漏洞"></a>7、图形验证码失效漏洞</h2><p>上面审计图形验证码时我们得知</p><p>开发人员为了开发方便，注释了判断验证码失效和判断验证码正误的代码，但项目上线时忘记取消注释，所以这里的验证码只需要不为空并且为4位字符即可，不会校验正误，如下</p><p><img src="/2023/12/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E2%80%94RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1701600223717-4fb5db10-0635-442c-b478-c009d91c7064.png" alt="img"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>这是我学习Java代码审计之后审计的第一个完整项目，花了2天时间，中间有很多代码的写法以及组件没有用过，导致比较陌生，所以需要花时间去查，去学，期间也发现了很多问题，熟悉了一些常用的组件，如何配置会有问题，如何配置才能安全。并且加深了我对权限管理一块的知识的理解。总结下来还是收获满满，成就感十足。</p>]]></content>
    
    
    <summary type="html">炼石计划第三阶段项目实战——RBAC权限管理系统审计笔记</summary>
    
    
    
    <category term="代码审计" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-security RegexRequestMatcher认证绕过漏洞</title>
    <link href="http://example.com/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-11-30T02:24:20.000Z</published>
    <updated>2023-12-22T02:07:08.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、漏洞简介"><a href="#一、漏洞简介" class="headerlink" title="一、漏洞简介"></a>一、漏洞简介</h1><p>当Spring-security使用 RegexRequestMatcher 进行权限配置，由RegexRequestMatcher正则表达式配置权限的特性，正则表达式中包含“.”时，未经身份验证攻击者可以通过构造恶意数据包绕过身份认证。</p><h1 id="二、影响版本"><a href="#二、影响版本" class="headerlink" title="二、影响版本"></a>二、影响版本</h1><p>Spring Security 5.5.x &lt; 5.5.7</p><p>Spring Security 5.6.x &lt; 5.6.4</p><h1 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h1><h2 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h2><p>这里我们搭建环境使用Github上一位大佬搭建的漏洞环境，链接如下</p><p><a href="https://github.com/XuCcc/VulEnv/tree/master/springboot/cve_2022_22978">https://github.com/XuCcc/VulEnv/tree/master/springboot/cve_2022_22978</a></p><p>将项目下载下来之后，编译之后在idae直接启动即可，启动之后页面如下</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701312633006-fd17f030-7598-4cd2-a0d9-072ef2dc5117.png" alt="img"></p><h2 id="2、观察环境"><a href="#2、观察环境" class="headerlink" title="2、观察环境"></a>2、观察环境</h2><p>该项目自定义了两个接口，并且引入了Springsecurity，所以这里自定义的&#x2F;admin&#x2F;{name}接口就需要认证</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701313559053-84cffd01-ad34-4a37-a96d-292ae9043084.png" alt="img"></p><p>再来回忆下刚才介绍Springsecurity这个漏洞时介绍的两个条件</p><ul><li><p>SpringSecurity版本符合要求</p></li><li><ul><li>Spring Security 5.5.x &lt; 5.5.7</li><li>Spring Security 5.6.x &lt; 5.6.4</li></ul></li><li><p>使用了RegexRequestMatcher正则表达式配置权限，并且正则表达式中包含”.”</p></li></ul><p>我们下面就来看看这个项目是否符合这两个条件，是否存在该漏洞</p><p>首先这是Spring-security的漏洞，所以我们自然要先看看该项目导入的Springsecurity版本,如下</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701312812015-29d2827c-78f7-409d-8b66-a4fe1d959e94.png" alt="img"></p><p>可以看到这里的Springsecurity的版本是5.6.3,符合上面的漏洞版本Spring Security 5.6.x &lt; 5.6.4，所以漏洞的版本前置条件已经达成了</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701313230680-3c00c471-497a-4bab-9786-b705c3dbfcc7.png" alt="img"></p><p>通过检索发现该项目确实使用了RegexMatcher正则表达式，并且正则表达式中包含”.”，初步判断存在该漏洞</p><h2 id="3、漏洞实操"><a href="#3、漏洞实操" class="headerlink" title="3、漏洞实操"></a>3、漏洞实操</h2><p>我们访问127.0.0.1:8080&#x2F;admin&#x2F;cyx,自动重定向到127.0.0.1:8080&#x2F;login这个默认登录页面。如下</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701313769329-0c315dee-5d69-43f6-a5df-d46b6c30335d.png" alt="img"></p><p>即认证生效，此时在&#x2F;admin&#x2F;cyx末尾加上如下字符<strong>其中一种</strong></p><ul><li>\r的URl编码为%0d</li><li>\n的URL编码为%0a</li></ul><p>即两种换行符，此时结果如下</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701313951102-6c10ece7-ab7a-4810-8274-bdba8f1cc63b.png" alt="img"></p><p>成功绕过Springsecurity的身份认证，访问到了受保护的资源</p><h1 id="四、漏洞分析"><a href="#四、漏洞分析" class="headerlink" title="四、漏洞分析"></a>四、漏洞分析</h1><p>在正则表达式中元字符“.”是匹配除换行符（\n、\r）之外的任何单个字符，在java中的正则默认情况下“.”也同样不会包含\n、\r字符，所以RegexRequestMatcher在进行正则匹配时不会处理\n、\r，如下</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701336568048-aca0bd86-f215-4b82-944f-1a8cc4b48e0e.png" alt="img"></p><p>如果目标站点的正则判断规则如下</p><pre><code class="java">regexMatchers(&quot;/admin/.*&quot;)</code></pre><p>此时键入如下路径</p><pre><code class="http">127.0.0.1:8080/admin/cyx%0d</code></pre><p>或</p><pre><code class="http">127.0.0.1:8080/admin/cyx%0a</code></pre><p>就不会个&#x2F;admin&#x2F;.*这个正则匹配成功，就不会被重定向到登录界面，从而访问到了受保护的&#x2F;admin下的资源，如下</p><p><img src="/2023/11/30/Spring-security-RegexRequestMatcher%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/1701337009740-80cd6346-e8ca-4654-bdb2-ed17374f400b.png" alt="img"></p><h1 id="五、修复手段"><a href="#五、修复手段" class="headerlink" title="五、修复手段"></a>五、修复手段</h1><p>在Springsecurity的新版本，将原先正则选择的默认匹配模式换为了DOTALL模式，此时的”.”就不会跳出判断规则从而导致绕过了</p><p>到这里本次漏洞分析就结束了，基于这个特性，Shiro也有对应的漏洞，我们后面也会对应的分析一次，理解他们的共性</p>]]></content>
    
    
    <summary type="html">Spring-security使用 RegexRequestMatcher 进行权限配置，且正则表达式中包含“.”时，未经身份验证攻击者可以通过构造恶意数据包绕过身份认证。</summary>
    
    
    
    <category term="漏洞复现" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>使用frps和frpc进行内网穿透</title>
    <link href="http://example.com/2023/11/23/%E4%BD%BF%E7%94%A8frps%E5%92%8Cfrpc%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://example.com/2023/11/23/%E4%BD%BF%E7%94%A8frps%E5%92%8Cfrpc%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2023-11-23T04:00:42.000Z</published>
    <updated>2023-11-23T05:49:24.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p>内网穿透的作用简单来说就是<strong>跨网段</strong>访问<strong>另一个局域网</strong>中的一台主机。</p><p><img src="/2023/11/23/%E4%BD%BF%E7%94%A8frps%E5%92%8Cfrpc%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20231123092952316.png" alt="image-20231123092952316"></p><p>如上图，假设我们想要通过主机A访问主机C，但是主机A和主机C绑定的都是私有ip地址，所以它们之间是无法直接进行通信的。要想使得A和C能够进行通信，就需要用到<strong>内网穿透</strong>的技术。</p><p>这里我们就可以通过下面讲到的<strong>frps</strong>和<strong>frpc</strong>来实现内网穿透，从而实现主机A和主机C之间的通信。</p><h1 id="frp简介"><a href="#frp简介" class="headerlink" title="frp简介"></a>frp简介</h1><p>frp可以通过有公网IP的的服务器将内网的主机暴露给互联网，从而实现通过外网能直接访问到内网主机；frp有服务端和客户端，服务端需要装在有公网ip的服务器上，客户端装在内网主机上。</p><p>frp下载地址：<a href="https://github.com/fatedier/frp/releases/">https://github.com/fatedier/frp/releases/</a></p><p>frp支持多种协议类型的内网穿透，包括SSH,rdp和socks，下面我们详细讲讲frp的使用方法</p><h1 id="配置讲解"><a href="#配置讲解" class="headerlink" title="配置讲解"></a>配置讲解</h1><p>在上面的官网中，下载下来的frp目录如下</p><p><img src="/2023/11/23/%E4%BD%BF%E7%94%A8frps%E5%92%8Cfrpc%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20231123110558002.png" alt="image-20231123110558002"></p><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>将frps.ini文件和frps文件上传到服务器，即主机B中</p><p>在主机B中，按照如下格式编辑frps.ini文件</p><pre><code class="txt">[common]# 客户端与服务端要连接的端口bind_port = 7000# ui仪表板的端口，账号，密码# 想用ui界面时取消注释即可# dashboard_port = 7500       # dashboard_user = admin# dashboard_pwd = admin# 客户端与服务端连接口令设置# 想设置验证时取消注释即可# authentication_method = token # token = pass123456</code></pre><p>使用如下命令</p><pre><code class="bash">./frps -c frps.ini</code></pre><p><img src="/2023/11/23/%E4%BD%BF%E7%94%A8frps%E5%92%8Cfrpc%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20231123093217749.png" alt="image-20231123093217749"></p><p>这样就成功开启了服务端的frps配置即开启</p><p>注意：如果提示没有权限，就加上执行权限即可。提示没有权限是因为你的frps程序是直接上传的，而不是上传压缩包进行解压得到的frps程序</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>在客户端，即主机C中，上传frpc和frpc.ini文件</p><p>编辑frpc.ini文件，格式如下：</p><pre><code class="txt">[common]# 设置建立连接的服务端的信息server_addr = x.x.x.x#公网ip地址server_port = 7000# 设置验证信息，frps文件设置了这里才设置# authentication_method = token# token = pass123456# 建立SSH穿透规则# 公网的20022端口接收的流量会转发到当前主机的22端口[Fusion-ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 20022# 设置rdp穿透规则# 即公网的23389端口接收的流量会转发得到当前主机的3389端口[Fusion-rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389remote_port = 23389# 设置socks穿透规则# 把公网的8989设置为当前主机的socks代理[Fusion_socks]type = tcpremote_port = 8989plugin = socks5</code></pre><p>再执行如下命令</p><pre><code class="bash">./frpc -c frpc.ini</code></pre><p><img src="/2023/11/23/%E4%BD%BF%E7%94%A8frps%E5%92%8Cfrpc%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/image-20231123093734906.png" alt="image-20231123093734906"></p><p>此时客户端的配置和连接也完成了，我们的内网穿透到这里就算配置好了</p><h1 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h1><p>师傅们看完上面的配置可能还是有点迷糊，例如配置信息为什么这么多？配置完之后怎么用？</p><p>没关系，下面我们通过几个例子，简单讲一下</p><p>这里假设我的公网vps（B主机）的ip是101.34.31.153</p><h2 id="一、A主机SSH登录C主机-无校验"><a href="#一、A主机SSH登录C主机-无校验" class="headerlink" title="一、A主机SSH登录C主机(无校验)"></a>一、A主机SSH登录C主机(无校验)</h2><h3 id="服务端配置-1"><a href="#服务端配置-1" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>这里B主机的frps.ini配置如下</p><pre><code class="txt">[common]# 客户端与服务端要连接的端口bind_port = 7000</code></pre><ul><li>因为无校验，所以这里不设置校验，即token</li><li>我想实现的是SSH登录C主机，自然没必要用到ui仪表盘，所以也不设置</li></ul><p>最终就形成了这样一个简单的配置文件，即只需要指定通信的端口</p><h3 id="客户端配置-1"><a href="#客户端配置-1" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>C主机的frpc.ini配置如下</p><pre><code class="txt">[common]# 设置建立连接的服务端的信息# 公网ip地址server_addr = 101.34.31.153server_port = 7000# 建立SSH穿透规则# 公网的20022端口接收的流量会转发到当前主机的22端口[Fusion-ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 20022</code></pre><ul><li>我们的目的是实现ssh登录，所以就不需要设置rdp和socks协议的穿透</li><li>B主机的frps没有设置验证，自然C主机的frpc文件也不用设置用于连接的验证</li></ul><p>最终就形成了这样的配置文件</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>B主机（服务端）执行</p><pre><code class="bash">./frps -c frps.ini</code></pre><p>C主机（客户端）执行</p><pre><code class="bash">./frpc - c frpc.ini</code></pre><p>即可成功建立连接，此时在A主机执行如下命令</p><pre><code class="bash">ssh user@101.34.31.153 -p 20022</code></pre><p>即可成功登录到主机C，实现目的</p><p>注意：如果在是windows，就使用xshell等工具使用ssh协议来连接即可</p><h2 id="二、在B主机建立C主机的socks代理"><a href="#二、在B主机建立C主机的socks代理" class="headerlink" title="二、在B主机建立C主机的socks代理"></a>二、在B主机建立C主机的socks代理</h2><h3 id="服务端配置-2"><a href="#服务端配置-2" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>同上</p><h3 id="客户端配置-2"><a href="#客户端配置-2" class="headerlink" title="客户端配置"></a>客户端配置</h3><pre><code>[common]# 设置建立连接的服务端的信息server_addr = 101.34.31.153server_port = 7000# 设置socks穿透规则# 把公网的8989设置为当前主机的socks代理[Fusion_socks]type = tcpremote_port = 8989plugin = socks5</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>客户端与服务端执行如上的命令建立连接即可</p><p>此时C主机的socks5代理会映射到B主机的8989端口，从而其他机器就可以使用B主机的socks代理访问C主机所在的局域网</p><p>此时的代理规则如下</p><pre><code class="bash">socks5://101.34.31.153:8989</code></pre><p>其他主机挂上这个代理即可访问C主机所在的局域网，即实现内网穿透</p><h2 id="三、A主机RDP登录C主机"><a href="#三、A主机RDP登录C主机" class="headerlink" title="三、A主机RDP登录C主机"></a>三、A主机RDP登录C主机</h2><h3 id="服务端配置-3"><a href="#服务端配置-3" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>如上</p><h3 id="客户端配置-3"><a href="#客户端配置-3" class="headerlink" title="客户端配置"></a>客户端配置</h3><pre><code class="txt">[common]# 设置建立连接的服务端的信息server_addr = 101.34.31.153server_port = 7000# 设置rdp穿透规则# 即公网的23389端口接收的流量会转发得到当前主机的3389端口[Fusion-rdp]type = tcplocal_ip = 127.0.0.1local_port = 3389remote_port = 23389</code></pre><p>这种方法适用于C主机开启了Windows远程桌面（3389）服务</p><ul><li>因为不需要ssh和socks，所以这两个都不用配置</li><li>同理，也不用设置验证</li></ul><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>服务端与客户端执行如上命令建立连接</p><p>下面分为A主机为Linux和A主机为Windows两种情况下，如何访问C主机的远程桌面</p><p><strong>Linux使用如下指令</strong></p><pre><code class="bash">rdesktop -u &lt;用户名&gt; -p &lt;密码&gt; &lt;目标Windows系统的IP地址或主机名&gt;</code></pre><p>Windows步骤如下</p><pre><code>1、WIN + R2、mstsc3、输入账密4、连接</code></pre><p>这样就能访问C主机的远程桌面了</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p><strong>多协议隧道</strong></p><p>刚才的rdp，ssh，socks三个协议，其实可以一起使用的，在frpc.ini文件中正常配置即可，并不会发生冲突，前提是端口没有冲突。</p><p><strong>后台命令</strong></p><p>直接执行时会占据当前终端页面，可以使用下面的命令把frp放到后台运行</p><pre><code class="bash">nohup ./frps -c frps.ini &amp; #后台运行</code></pre><p>加入nohup之后终端关闭之后也会继续运行，不加的话也可以，&amp;也是放到后台，但是终端关闭就会停止，看个人选择</p>]]></content>
    
    
    <summary type="html">frp是什么？如何使用frp实现内网穿透？一文带你了解frp使用姿势</summary>
    
    
    
    <category term="内网攻防" scheme="http://example.com/categories/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2/"/>
    
    
    <category term="内网穿透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>SSH两种远程登录方式及原理剖析</title>
    <link href="http://example.com/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>http://example.com/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</id>
    <published>2023-11-04T03:12:54.000Z</published>
    <updated>2023-11-04T03:17:29.931Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  SSH的口令登录，密钥登录，别名登录，绕着绕着就把自己绕晕了，所以写下这篇博客来详细剖析一个SSH的登录方法和原理</p></blockquote><hr><h2 id="一：SSH口令登录"><a href="#一：SSH口令登录" class="headerlink" title="一：SSH口令登录"></a>一：SSH口令登录</h2><h3 id="【1】登录原理"><a href="#【1】登录原理" class="headerlink" title="【1】登录原理"></a>【1】登录原理</h3><p>SSH服务<strong>默认登录方式</strong>为<strong>口令登录</strong>，也是我们平时最常用的，原理如下</p><blockquote><ul><li>1.客户端向服务端发起<strong>请求</strong></li><li>2.服务端收到请求将自己生成的<strong>公钥返回</strong>给客户端</li><li>3.客户端用返回来的公钥<strong>加密</strong>自己的登录密码，发送给服务端</li><li>4.服务端用自己的私钥<strong>解密</strong>，并<strong>验证</strong>密码是否正确，如果正确，允许登录</li></ul></blockquote><p>可以看到整个流程存在四个步骤 ，下面给大家详细讲讲使用方法</p><h3 id="【2】使用教程"><a href="#【2】使用教程" class="headerlink" title="【2】使用教程"></a>【2】使用教程</h3><p>SSH的基本使用方法是：</p><pre><code class="null">ssh user@remote -p port</code></pre><ul><li>user 是你在远程机器上的<strong>用户名</strong>，如果不指定的话默认为当前用户</li><li>remote 是远程机器的<strong>地址</strong>，可以是 IP，域名，或者是后面会提到的别名</li><li>port 是 SSH Server 监听的<strong>端口</strong>，如果不指定的话就为默认值 22（ssh的默认端口）</li></ul><blockquote><p>  所以，SSH口令登录的前提就是知道目标的<strong>用户名</strong>，<strong>地址</strong>和SSH服务的<strong>端口</strong>，缺一不可</p></blockquote><h4 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1.建立连接"></a>1.建立连接</h4><p><strong>举例</strong>：假如我正在使用kali机器做渗透测试，探测到目标的地址是</p><p>开启了22端口，并且是SSH服务，还知道了目标机器上的用户名为Tom，密码为123456，就可以用SSH远程登录到目标机器，指令如下</p><pre><code class="null">ssh tom@172.21.70.110 -p 22</code></pre><p><strong>注</strong>：这里的-p 22也可以不要，因为-p 22是默认选项，如果是其他端口的ssh服务就需要用-p来指定其他的端口了</p><h4 id="2-输入密码"><a href="#2-输入密码" class="headerlink" title="2.输入密码"></a>2.输入密码</h4><p>输入上面的指令后页面如下，提示输入密码，这里密码的输入是隐藏输入（并不会显示），输入密码后直接回车就好 </p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/e81774a888814d1a81bd6acfc6949b69.png"></p><blockquote><p>因为我已经连接过很多次了，但是第一次连接会弹出来一段话，意思是该远程主机的真实性无法确定，确定想要继续连接吗？ ，直接输入yes即可</p></blockquote><h4 id="3-成功连接"><a href="#3-成功连接" class="headerlink" title="3.成功连接"></a>3.成功连接</h4><p> 输入密码后页面如下图</p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d0af46c56718435283ee4d9c7ca4822e.png"></p><p> 可以看到这里我们成功用SSH远程登录了目标的tom用户，这就是SSH口令登录的大致内容了</p><h3 id="【3】缺点总结"><a href="#【3】缺点总结" class="headerlink" title="【3】缺点总结"></a>【3】缺点总结</h3><h4 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1.安全性"></a>1.安全性</h4><p>整个验证机制是没什么问题的，但是当遇到 **<code>中间人攻击</code>**这种机制的安全性便会遭到破坏，什么是 <code>**中间人攻击**？</code></p><blockquote><ul><li>客户端向服务端发起请求</li><li><strong>攻击人截获请求，并向客户端返回自己的公钥</strong></li><li>客户端用公钥加密登录密码并返回</li><li><strong>攻击人用自己的私钥解密，获得服务器的登录密码</strong></li></ul></blockquote><h4 id="2-繁琐性"><a href="#2-繁琐性" class="headerlink" title="2.繁琐性"></a>2.繁琐性</h4><p>每次登录目标主机都要输入密码，短的密码不安全，长的密码又不好记，用户体验感较差</p><blockquote><p>为了解决上面这几个问题，于是更新，更安全的方法随之而生，那就是SSH秘钥登录，下面我们来看看</p></blockquote><h2 id="二：SSH秘钥登录"><a href="#二：SSH秘钥登录" class="headerlink" title="二：SSH秘钥登录"></a>二：SSH秘钥登录</h2><h3 id="【1】登录原理-1"><a href="#【1】登录原理-1" class="headerlink" title="【1】登录原理"></a>【1】登录原理</h3><p>很多人可能都听过秘钥登录，知道它可以通过SSH在<strong>无需密码</strong>的情况下登录目标机器上的用户，那这个流程是怎样的呢？我们来详细看看 </p><blockquote><ul><li>1.客户端<strong>自己生成</strong>密钥对，事先将<strong>公钥上传存储</strong>到远程服务器上，私钥<strong>自己保管</strong></li><li>2.客户端发起登录请求</li><li>3.服务器生成一串<strong>随机字符串，</strong>并用<strong>公钥加密</strong>，加密后的结果发给客户端</li><li>4.客户端用自己的<strong>私钥解密</strong>随机字符串，返回给服务端</li><li>5.服务端将<strong>收到的随机字符串</strong>与事先<strong>生成的随机字符串</strong>比对，正确则允许登录</li></ul></blockquote><p> 可以看到整个流程存在五个步骤 ，下面给大家看看<strong>详细步骤</strong> </p><h3 id="【2】使用教程-1"><a href="#【2】使用教程-1" class="headerlink" title="【2】使用教程"></a>【2】使用教程</h3><h4 id="1-生成密钥对"><a href="#1-生成密钥对" class="headerlink" title="1.生成密钥对"></a>1.生成密钥对</h4><pre><code class="null">ssh-keygen -t rsa   #-t表示类型选项，这里采用rsa加密算法</code></pre><p>然后根据提示一步步的按回车键即可（总共三个），页面如下</p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/0307fc888524478bb81aac4fdc5db915.png"></p><p>这里为什么连续按三个回车就可以了呢，我们来看看这三个回车对应了什么 </p><blockquote><p><strong>第一个回车</strong>：让我们输入一个目录路径来保存生成的密钥对，默认为**&#x2F;root&#x2F;.ssh<strong>，回车                                 代表</strong>直接默认**，也可以自己输入一个路径来保存 </p><p><strong>第二个回车</strong>：让我们设置私钥密码，如果设置了私钥密码，每次使用 SSH 进行操作都需要                          输入私钥密码。这里直接空格就是密码为空，这样每次使用就不需要输入密码</p><p><strong>第三个回车：</strong> 这个就是单纯的再次输入私钥密码（就是一个确认密码），我们本来就是没想                       设置密码，所以还是直接回车即可</p></blockquote><p>像我上面那样的话<strong>密钥对</strong>就已经生成了，我们到自己设置的<strong>秘钥对</strong>路径下看看，如果没有设置路径的话就是默认路径**&#x2F;root&#x2F;.ssh**，查询结果如下</p><p> <img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/78466f2ff0724b8e94cb5243da0b5536.png"></p><p> 可以看到在&#x2F;root&#x2F;.ssh路径下生成了密钥对（即公钥和私钥），其中<strong>id_rsa文件</strong>就是<strong>私钥</strong>，<strong>id_rsa.pub文件</strong>就是<strong>公钥</strong></p><h4 id="2-投递公钥到服务端"><a href="#2-投递公钥到服务端" class="headerlink" title="2.投递公钥到服务端"></a>2.投递公钥到服务端</h4><p> 上面我们已经生成了密钥对，按照步骤需要将<strong>密钥对中的公钥</strong>保存到目标机器的**~<strong>&#x2F;.ssh&#x2F;authorized_key文件中，这里给大家介绍</strong>三种<strong>投递方式，但都是基于目标</strong>开启了ssh服务<strong>和</strong>知道目标账密**的前提下</p><blockquote><p>注意：~ 表示代码主目录，也就是我们想用SSH登录的用户目录。 </p></blockquote><p><strong>第一种:</strong></p><p>这是最简单也是<strong>最常用</strong>的方式，需要<strong>ssh-copy-id</strong>，但是一般linux都自带这个</p><pre><code class="null">ssh-copy-id user@remote -p port</code></pre><ul><li>user 是你在远程机器上的<strong>用户名</strong>，如果不指定的话默认为当前用户</li><li>remote 是远程机器的<strong>地址</strong>，可以是 IP，域名，或者是后面会提到的别名</li><li>port 是 SSH Server 监听的<strong>端口</strong>，如果不指定的话就为默认值 22（ssh的默认端口）</li></ul><p><strong>实例</strong>： 这里我直接把上面生成的<strong>密钥对中的公钥</strong>上传到目标机器的<strong>tom用户目录</strong>下</p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/21755392d777404da33f6eb6479af988.png"></p><p> 可以看到在这里已经成功上传了，因为这是我们自己搭建的环境，我们也可以去目标机器看看**~&#x2F;.ssh<strong>上有没有我们上传的公钥文件，也就是</strong>authorized_keys<strong>文件（上传后会经过</strong>重命名**）</p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1e8f5fb59c1a4201b43bddc6b517cd79.png"><br> 可以看到目标路径下已经有了，现在我们再用kali来登录试试</p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/f39122939df54e97904ccfd4d6afb050.png"></p><p> 可以看到已经成功登录了，而且并没有提示我们输入密码</p><p><strong>第二种：</strong> </p><p>在<strong>没有 ssh-copy-id</strong> 的情况下（比如在 Windows 上），也是可以轻松做到这件事的。用命令的话也是一句话搞定 </p><pre><code class="null">ssh user@remote -p port &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></pre><p> 这句话的意思是，在远端执行新建 .ssh 文件夹，并把本地的 ~&#x2F;.ssh&#x2F;id_rsa.pub （也就是公钥）复制为远端的 <strong>.ssh&#x2F;authorized_keys文件</strong>，因为windows用得少，这里就不实操举例了，有兴趣的同学可以试试</p><p><strong>第三种：</strong> </p><p> 咳咳，这个其实也不算方法，就是两台电脑均可控的情况下，手动把本地的 <strong>~&#x2F;.ssh&#x2F;id_rsa.pub</strong>复制到目标机器的~&#x2F;<strong>.ssh&#x2F;authorized_keys文件</strong>中</p><h2 id="三：SSH最简单登录方法——别名配置"><a href="#三：SSH最简单登录方法——别名配置" class="headerlink" title="三：SSH最简单登录方法——别名配置"></a>三：SSH最简单登录方法——别名配置</h2><p>每次都输入 <strong>ssh user@remote -p port</strong>，时间久了也会觉得很麻烦（不要觉得我懒哈哈），特别是当 <strong>user</strong>, <strong>remote</strong> 和 <strong>port</strong> 都得输入，而且还不好记忆的时候。配置别名可以让我们<strong>进一步偷懒</strong>（咳咳）。</p><p>比如我想用 <strong>ssh  host1</strong>来替代上面这么一长串，那么在 <strong>~&#x2F;.ssh&#x2F;config</strong>文件里面追加以下内容： </p><pre><code class="null">Host host1    HostName remote    User user    Port port</code></pre><p><strong>举例：</strong>  先在本地的**~&#x2F;.ssh<strong>里面创建一个名为</strong>config**的文件，里面代码如下：</p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1a9861ce30834f26aa786dd18e32bf20.png"></p><p> 现在我们就可以尝试使用<strong>ssh host1</strong>来登录了，如下</p><p><img src="/2023/11/04/SSH%E4%B8%A4%E7%A7%8D%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4ec6c8b28f4f4242a878cb0030a470e0.png"></p><blockquote><p>可以看到，也能成功登录，并且与刚才配置的<strong>秘钥登录</strong>配合，不用输入密码，目标信息不用记，我说这是ssh<strong>最简单</strong>的登录方法没问题吧。</p></blockquote><p><strong>注意</strong>：这个别名并不是必须配置公钥登录，这里如果没有配置秘钥登录也可以使用别名，只是登    录时需要输入密码而已</p><hr><blockquote><p>  好了今天的SSH使用技巧分享就到这里了，如果有什么疑问或者想讨论的都可以私信我或者发布评论，看到都会回哦（如果有什么网安方面的小问题也可以来讨论讨论），最后，希望今天的内容能对大家有所帮助，感谢大家的阅读，再见啦!</p></blockquote>]]></content>
    
    
    <summary type="html">SSH的登录方式有哪些？还在用密码登录吗？本文从原理出发，带你了解SSH的两种远程登录方式。教你巧用SSH</summary>
    
    
    
    <category term="安全知识" scheme="http://example.com/categories/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Web安全" scheme="http://example.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
    <category term="SSH密钥" scheme="http://example.com/tags/SSH%E5%AF%86%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>验证码漏洞挖掘方式-下-图像验证码</title>
    <link href="http://example.com/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://example.com/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2023-11-04T02:41:59.000Z</published>
    <updated>2023-12-22T02:11:11.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于图像验证码的安全漏洞"><a href="#基于图像验证码的安全漏洞" class="headerlink" title="基于图像验证码的安全漏洞"></a>基于图像验证码的安全漏洞</h1><p>平时测试时，看到下面<strong>图片验证码</strong>你能够想到什么漏洞测试思路？</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230527102353837.png" alt="image-20230527102353837"></p><p><strong>验证码</strong>的安全问题一直都是逻辑漏洞领域的一大话题，当前的验证码主要分为两类，一是“<strong>短信验证码</strong>”,一个是”<strong>图片验证码</strong>“，当然还有谷歌的图片点击等各种各样的验证码，但目前主流的验证码还是这两个。</p><p>目前，<strong>图片验证码</strong>的安全包含了下面的这几个方面，这也是我测短信验证码漏洞的主要方向</p><ul><li>图形验证码失效漏洞</li><li>图形验证码可被OCR识别漏洞</li><li>图形验证码Dos漏洞</li></ul><p>这里就是我能想到的常规的短信验证码漏洞，也可能还有其他姿势</p><p>本篇文章我们就用这几个漏洞来讨论<strong>短信验证码的安全性</strong>问题</p><h2 id="一、图形验证码失效漏洞"><a href="#一、图形验证码失效漏洞" class="headerlink" title="一、图形验证码失效漏洞"></a>一、图形验证码失效漏洞</h2><p>这个是我自己取的一个名字，大概指的就是因为各种原因而造成的图片识别验证码失效的漏洞，因为细说下来太多了，所以在这里就<strong>举几个例子让大家感受一下</strong></p><p>先来说说图形验证码的验证流程</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531233347774.png" alt="image-20230531233347774"></p><p>首先服务器生成图形验证码，下发验证码图片的同时也下发了一段 esion，此时图形验正码正确的文本内容与 Sesion是绑定的。当用户完成验证码填写并提交表单时，服务器校验当能用户提交的验证码文本和用户 Cookie所对应的Session信息。二者如果一致，则验证码验正道过，如果不一致则返回验证码错误。</p><h3 id="例1：前端校验失效"><a href="#例1：前端校验失效" class="headerlink" title="例1：前端校验失效"></a>例1：前端校验失效</h3><p>有些网站不使用Session而使用JavaScript在用户前端校验码填写是否正确。此时，交互过程会有一个明显的特征，用户填写好验证码之后不需要与服务器端交互即可得到验证码是否填写正确的提示。这说明验证码的验证逻辑在前端，参照前端校验漏洞一节，可以通过修改JavaScript来轻易绕过此类图形验证码。</p><h3 id="例2：验证流程不当信息泄露"><a href="#例2：验证流程不当信息泄露" class="headerlink" title="例2：验证流程不当信息泄露"></a>例2：验证流程不当信息泄露</h3><p>有些网站在验证用户提交的表单时，并没有首先进行验证码校验，而是先校验用户id是否存在，若不存在返回“用户名不存在”的提示信息。此时，可随意填写图片验证码，来批量遍历出系统中已注册的用户名列表。</p><h3 id="例3：验证码刷新配置不当"><a href="#例3：验证码刷新配置不当" class="headerlink" title="例3：验证码刷新配置不当"></a>例3：验证码刷新配置不当</h3><p>有些网站的下发验证码接口，仅当用户请求验证码生成接口时才会动态刷新。攻击者可以通过Burp抓包的方法，使用<strong>drop</strong>阻断请求验证码生成接口的请求，使用固定验证码进行批量破解，这种问题是很常见的</p><h3 id="例4：旧接口兼容问题"><a href="#例4：旧接口兼容问题" class="headerlink" title="例4：旧接口兼容问题"></a>例4：旧接口兼容问题</h3><p>有些网站之前的登录验证接口是没有验证码的，而后面由于功能需求增加了验证码验证功能。但为了兼容旧按口，就判断用户提交表单是否提交了verifycode 参数，如果没有提交则不进行校验码检验。这种场景下，只需要通过BupSuitc修改请求包，将verifycode参数去掉即可实现绕过。</p><h3 id="例5：用户登录次数绕过"><a href="#例5：用户登录次数绕过" class="headerlink" title="例5：用户登录次数绕过"></a>例5：用户登录次数绕过</h3><p>一些对用户体验有要求的网站，在登录接口设计时，会首先不弹出验证码。此时，用户登录不需要输入图形验证码，而当用户登录失败超过3次以后，则强制要求用户填写图形验证码。这样做无疑会极大提升用户体验。</p><p>但是，有一些网站判断用户登录失败次数，采用 session计数的方式，当用户登录失败超过3次时，攻击者可以清空自己的cookie，要求服务器下发新的 Session以继续登录，此时，仍然是不需要填写验证码的。因而，可以通过自动化工具尝试登录，每次请求都要求服务器生成新的Session，错误次数永远为1，则绕过了图形验证码机制。</p><p>以上几种场景，均属于图形验证码失效，希望读师傅们在进行网站安全测试时能够举一反三。</p><h2 id="二、图形验证码可被OCR识别漏洞"><a href="#二、图形验证码可被OCR识别漏洞" class="headerlink" title="二、图形验证码可被OCR识别漏洞"></a>二、图形验证码可被OCR识别漏洞</h2><p>早期，一些较为清晰的图形验证码是可以使用OCR工具自动化识别的。这也是为什么验证码发展历程中，先后出现了数字验证码、数字加字母验证码、汉字验证码、数学计算公式验证码、滑块拼图验证码、通过旋转使图形满足正确方向的验证码、根据描述从给定图片中拣选图片中包含对应描述物品的验证码(图像拣选验证码)等一系列连入类都难以通过验证的验证码识别技术。</p><h4 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a>Python脚本</h4><p>以Python为例，可以利用<strong>tesseract</strong>进行识别。首先需要下载和编译tesseract，</p><p><strong>注</strong>：<strong>Tesseract</strong>是github上的OCR开源库，今天我将使用Tesseract来进行文字识别。</p><p>windows下载可以直接到Github</p><p><a href="https://github.com/tesseract-ocr/tesseract">tesseract-ocr&#x2F;tesseract: Tesseract Open Source OCR Engine (main repository) (github.com)</a></p><p>对于macOS系统的用户来说，可以使用如下命令来轻松完成安装。</p><pre><code class="py">brew install tesseract</code></pre><p>然后利用以下Python脚本，在运行前，需要使用pip安装两个库：Pillow、pytesseract，使用如下命令。</p><pre><code class="py">pip install Pillowpip install pytesseract</code></pre><p>接下来，将需要识别的验证码图片保存为targetjpg，运行以下脚本。</p><pre><code class="py">from PIL import Imageimport pytesseracttext = pytesseract.image_to_string(Image.open(r&#39;./target.jpg&#39;),lang=&#39;eng&#39;) print(text)</code></pre><p>识别效果如下</p><h4 id="Burp插件"><a href="#Burp插件" class="headerlink" title="Burp插件"></a>Burp插件</h4><p>Burp中也有很多的插件来实现图片验证码识别的功能，有的是调用的收费接口，也有的是用的免费的，我给大家找了一个免费的Burp验证码识别插件，有兴趣的也可以去看看</p><p>插件链接如下</p><p><a href="https://github.com/f0ng/captcha-killer-modified">https://github.com/f0ng/captcha-killer-modified</a></p><p>具体的使用也可以咋github上看到</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230601151804482.png" alt="image-20230601151804482"></p><p>基本上简单的验证码识别还是没问题</p><p>随着技术的更新OCR可识别这种情况出现的越来越少了，但并不是没有办法解决，例如人工打码平台，这后面的可是实实在在的人，只是成本较高，但如果受攻击的是一个注册接口，而商家又有“新用户赠送20元新人红包”，那么使用人工打码平台实现批量注册，所获得的利润就是几十倍，几百倍</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230601113247355.png" alt="image-20230601113247355"></p><p>站在防御者的角度，能做的就是提高攻击成本，当攻击成本大于受益时，就很少人去攻击了。具体的做法还需要多研究。</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230601152714508.png" alt="image-20230601152714508"></p><h2 id="三、图形验证码Dos漏洞"><a href="#三、图形验证码Dos漏洞" class="headerlink" title="三、图形验证码Dos漏洞"></a>三、图形验证码Dos漏洞</h2><p>这个测着最简单，而且遇到的频率也不算很低</p><p>当你遇到目标站点使用的是图形验证码时，如果它的url，接口，或者生成请求中存在类似“weight&#x3D;110&amp;height&#x3D;70”这种生成图像的设定参数可控（一般右键选择“在新标签页中打开图像”看看验证码的url就行），也就是你能控制图像的大小，那么就很可能存在这个漏洞，例如下面这样</p><pre><code class="py">https://www.xxxx.cn/verifyCode.do?width=110&amp;height=40&amp;random=1685175156944</code></pre><p><strong><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230527161321962.png" alt="image-20230527161321962"></strong></p><p>此时如果你将生成图像的参数设置的很大，而生成之后的图像也随之变大（也就是真正可控）,例如我们把height参数的值40改为1000，那么效果如下</p><pre><code class="pyh">https://www.xxxx.cn/verifyCode.do?width=110&amp;height=1000&amp;random=1685175156944</code></pre><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230527161636902.png" alt="image-20230527161636902"></p><p>注意此时肉眼可见的会发现服务器响应变慢，如果更直观的话就是拿到bp的<strong>repeater模块</strong>发包，观察response的响应时间和数据量，也就是下面这个位置</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8B)-%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230527162556516.png" alt="image-20230527162556516"></p><p>而图形验证码的生成大多都基于复杂的图像生成算法，本来就很消耗CPU,GPU性能，此时攻击者再把尺寸增大，就会成倍消耗性能，如果大到一定程度再结合<strong>高并发</strong>，服务器很有可能瞬间崩溃，也就造成了Dos攻击</p><p>SS</p>]]></content>
    
    
    <summary type="html">上一篇文章我们讲解了短信验证码的安全问题，而今天的文章要讲解的就是验证码的另外一种主流验证码——“图像验证码”安全性问题</summary>
    
    
    
    <category term="SRC挖掘" scheme="http://example.com/categories/SRC%E6%8C%96%E6%8E%98/"/>
    
    
    <category term="Web安全" scheme="http://example.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
    <category term="逻辑漏洞" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="SRC挖掘" scheme="http://example.com/tags/SRC%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>验证码漏洞挖掘方式(上)-短信验证码</title>
    <link href="http://example.com/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://example.com/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2023-11-04T02:33:47.000Z</published>
    <updated>2023-12-22T02:11:25.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于短信验证码的安全漏洞"><a href="#基于短信验证码的安全漏洞" class="headerlink" title="基于短信验证码的安全漏洞"></a>基于短信验证码的安全漏洞</h1><p>平时测试时，看到下面<strong>短信验证码</strong>你能够想到什么漏洞测试思路？</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230527111409518.png" alt="image-20230527111409518"></p><p><strong>验证码</strong>的安全问题一直都是逻辑漏洞领域的一大话题，当前的验证码主要分为两类，一是“<strong>短信验证码</strong>”,一个是”<strong>图片验证码</strong>“，当然还有谷歌的图片点击等各种各样的验证码，但目前主流的验证码还是这两个。</p><p>目前，<strong>短信验证码</strong>的安全包含了下面的这几个方面，这也是我测短信验证码漏洞的主要方向</p><ul><li>暴力生成（短信爆破）</li><li>暴力破解</li><li>暴力生成破解</li><li>内容伪造</li><li>服务端回显</li><li>绑定关系失效</li><li>统一初始化</li></ul><p>这里就是我能想到的常规的短信验证码漏洞，也可能还有其他姿势</p><p>本篇文章我们就用这几个漏洞来讨论<strong>短信验证码的安全性</strong>问题</p><h2 id="一、暴力生成"><a href="#一、暴力生成" class="headerlink" title="一、暴力生成"></a>一、暴力生成</h2><p><strong>暴力生成</strong>通俗来讲就是<strong>短信轰炸</strong>，除此之外还有很多名字，<strong>短信接口DDos</strong>，<strong>短信验证码无限发送</strong>等，都是它。</p><p>指的就是开发者对短信验证功能点的发送短信次数没有限制，或者限制不严，导致攻击者可以利用该漏洞对任意手机号无限发送短信，使目标手机持续收到提醒，造成短信轰炸。由于网站发送短信是需要购买短信资源池的，所以在影响目标的同时造成网站的损失。</p><p>那么有人会问了，那该如何挖掘或者测试目标有没有这种漏洞呢？流程如下</p><ul><li><p>先填写你自己的手机号(为了观察效果)</p></li><li><p>开启bp抓包，点击<strong>发送验证码</strong></p></li><li><p>将抓到的发送短信的bp包发到repeater（也就是重放模块）</p></li><li><p>先直接连续点击send观察回显和手机的验证码收取情况</p></li><li><p>受到限制的话就修改请求包尝试绕过</p><ul><li>修改电话号，+86，+特殊符号等</li><li>修改请求包的个别参数（如果请求包传递的参数除了电话号还有其他的）</li></ul></li></ul><p>来看一个案例，某个短信验证发起短信的请求包如下：</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531160729891.png" alt="image-20230531160729891"></p><p>可以看到这里传输的参数除了mobile（电话）之外还有一个smsType，而这里是有限制一分钟只能发一次，但是经过测试，修改smsType参数的值，就可以绕过这个限制。</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531161356247.png" alt="image-20230531161356247"></p><p>思考一下这是什么原因？因为<strong>smsType</strong>代表短信类型，有可能这个短信是用于登录验证，有一个smsType，而另一个地方用于注册，也需要短信验证码，所以也需要一个短信验证码类型（如果<strong>需要短信验证码不同</strong>的话），简单来说就是下面这样</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531162255785.png" alt="image-20230531162255785"></p><p>而他有可能限制你在注册时一分钟只用接收一个验证码，其他的地方没限制，所以可以通过修改这个smsType参数，这个参数也是非常经典的。</p><p>但现在很多厂商已经把验证码做成一样了，比如京东，什么操作的验证码都是一样的类型</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531162640848.png" alt="image-20230531162640848"></p><p>所以此时发送验证码时的可控参数只有电话号，这时候只能测测改改电话号，或者尝试下面这些方法</p><p>同时针对这一问题的防御方法也很简单，只需要限制灭每个手机号一个时间段内能发送短信的最大次数即可，比如限制一分钟一次的同时，给每个手机号限制一天最多10次，这样，即使绕过了一分钟限制，也绕不过10次的限制</p><h2 id="二、暴力破解"><a href="#二、暴力破解" class="headerlink" title="二、暴力破解"></a>二、暴力破解</h2><p>短信验证码通常是4位或者6位数字，这也给攻击者爆破带来了可能性，要知道一台普通计算机破解6位数字(（也就是100万个请求），只需要不到1h的时间，更不用说采用分布式来大规模破解了，因此，如果网站对验证码接口不做限制的话，就很可能存在暴力破解的漏洞</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531172026425.png" alt="image-20230531172026425"></p><p>这个防御就更简单了，设置最大错误次数，比如错了几次就不让你登录了，3~5次即可</p><h2 id="三、暴力生成破解"><a href="#三、暴力生成破解" class="headerlink" title="三、暴力生成破解"></a>三、暴力生成破解</h2><p>​        有这样一种场景：网站虽然在验证码验证接口设置了最大错误阈值，但是，缺忽略了暴力生成漏洞，也就是短信轰炸漏洞，导致短信验证码可以被无限生成，是否一样会存在被暴力破解导致攻击者获取争取验证码的风险呢？<br>​        没错，在这种场景下，攻击者可以使用暴力生成破解的方法，虽然每个验证码只可以验证一次或几次，但是可以无限生成，攻击者每生成1次就破解1次即可绕过验证次数的限制了<br>​这样的场景也给我们带来了一些启发：攻防对抗是多因子对抗，在考虑一种防御方法的同时也要考虑其他因子带来的干扰，避免刻舟求剑，墨守成规。</p><h2 id="四、内容伪造"><a href="#四、内容伪造" class="headerlink" title="四、内容伪造"></a>四、内容伪造</h2><p>​        运营商提供短信验证码发送接口时，通常会开放验证码内容的编辑模板，而一些网站，会将验证码内容也作为用户提交的参数进行接收和变更。这样一来，攻击者就可以自定义短信发送的内容。利用自定义的内容来对网站用户批量发送，甚至还可以用来做钓鱼攻击。</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531164700187.png" alt="image-20230531164700187"></p><p>某公司的用户找回密码的验证码发送接口存在内容伪造漏洞，验证码默认的内容为：</p><p>​          “【xx 公司】您正在重置登录密码，短信验证码是：406798。”攻击者通过修改短信模板，将内容变为：“【xx公司】由于本行系统升级，请您编辑短信发送到：133xxxx1111，短信内容：XX+客户编号，您的临时客户编号是：406798。”<br>​          受害者如果看到该短信，信以为真，就会将自己的重置密码验证码发送给到攻击者手机，攻击者就可以修改受害者在网站上的登录密码，以受害者的身份信息进行登录了。<br>​          在实际测试中，可通过观察发送短信时，请求包内容是否包含接收短信中的内容来进行判断。若包含，则可以进一步修改短信内容，观察收到的短信内容是否受到影响，来判断漏洞点的存在与否。</p><h2 id="五、服务端回显"><a href="#五、服务端回显" class="headerlink" title="五、服务端回显"></a>五、服务端回显</h2><p>服务端回显短信验证码马是十分常见的一种漏洞，网站开发人员可能为了调试的方便，有时会将短信验证码发送的数字回显在发送成功的响应报文，也就是bp抓包的回显包。</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531171631722.png" alt="image-20230531171631722"></p><p>由于短信发送接口大多数都采用AJAX架构涉及，发送成功时用户界面正常只能看到“发送成功”的字样，并不会把验证码信息显示出来（正经人谁抓包），所以此时攻击者就可以抓包直接获取短信验证码。</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531171649031.png" alt="image-20230531171649031"></p><p>看似平平无奇的一个打印操作，带来的后果却是十分严重的。</p><h2 id="六、绑定关系失效"><a href="#六、绑定关系失效" class="headerlink" title="六、绑定关系失效"></a>六、绑定关系失效</h2><p>​        短信验证码失效是指短信验证码原本需要与手机号进行绑起，而在验证环节并没有验证验证手机号绑定关系，形成漏洞。<br>​        该漏洞表现为：当攻击者发送验证短信时使用自己的手机号进行发送，而在提交验证码时，从数据包中篡改手机号信息，从而使用其他手机号完成注册、登录或绑定等，简单来说就是用自己的电话号注册任意用户，形成<strong>任意手机号注册或登录漏洞</strong>。</p><p><img src="/2023/11/04/%E9%AA%8C%E8%AF%81%E7%A0%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E5%BC%8F(%E4%B8%8A)-%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20230531171114532.png" alt="image-20230531171114532"></p><p>该漏洞形成的原因一般有以下几种。</p><ul><li><p>1)服务器将验证码与Session绑定，而未与发送短信时的手机号进行绑定，或只在前端限制手机号不可修改。</p></li><li><p>2)服务器最终提交的接口中允许有<strong>两个手机号字段</strong>：验证码对应的验证手机号、用户实际提交的希望注册或绑定的手机号。两个字段不一致，但服务器并未校验。此时输入自己手机收到的验证码并点击提交抓包</p><ul><li>把电话末尾加逗号，再跟一个电话，看能否同时注册两个</li><li>比如账户参数是mobile，则再写一个mobile参数并传第二个手机号</li></ul></li><li><p>3)服务端在Session中保存所发送手机号的记录，但攻击者通过覆盖发送记录的方法绕过。</p></li></ul><p>对于该漏洞的防御，需要在判断用户提交的短信验证码时，严格校验该验证码发送时所对应的手机号，在用户提交其他参数时也应当校验参数中的手机号字段与验证手机号是否一致。</p><h2 id="七、统一初始化"><a href="#七、统一初始化" class="headerlink" title="七、统一初始化"></a>七、统一初始化</h2><p>​       统一初始化短信验证码是指短信验证码存在默认值，当一个手机号从未发送过短信验证码时直接验证可使用如“000000”“null”“none”“0”等字段进行校验。<br>​       该漏洞是由于开发人员在数据库初始化时为验证码字段设置默认值导致的。另外一种情况，对于一些有测试环境的应用，开发人员为了调试方便往往使用较为简单的短信验证码，如“123456”“000000”。当迁移到生产环境后，忘记对数据库中的验证码字段进行删除。</p><p>​       测试时，可以先使用BurpSuite 拦截发送验证码的请求，然后使用“000000”“0”等可能的初始化值进行提交判断。<br>​       测试该漏洞时，可利用“smscode&#x3D;”来提交一个值为空的数据(smscode 代指当前网站短信验证码参数的名称，需要结合实际情况进行修改)。<br>​       防御该漏洞，需要避免将测试数据带入到生产环境，不设置统一的初始化验证码。并且，为每次接收短信验证码的手机修改状态，在用户提交验证校验码是否正确的请求时，判断该手机号是否已进行发送验证码的流程，若从未发送过验证码，网站应当返回验证失败。</p><h1 id="八、随意验证码"><a href="#八、随意验证码" class="headerlink" title="八、随意验证码"></a>八、随意验证码</h1><p>获取验证码之后随意填写，只要位数对就行，说白了就是开发层面没有进行校验验证码是否正确、 </p>]]></content>
    
    
    <summary type="html">验证码的安全问题一直都是逻辑漏洞领域的一大话题，当前的验证码主要分为两类，一是“短信验证码”,一个是&quot;图像验证码&quot;，今天的文章要讲解的就是短信验证码的安全性问题</summary>
    
    
    
    <category term="SRC挖掘" scheme="http://example.com/categories/SRC%E6%8C%96%E6%8E%98/"/>
    
    
    <category term="Web安全" scheme="http://example.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
    <category term="逻辑漏洞" scheme="http://example.com/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="SRC挖掘" scheme="http://example.com/tags/SRC%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>大型Web资产信息收集</title>
    <link href="http://example.com/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://example.com/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2023-11-04T00:41:23.000Z</published>
    <updated>2023-11-04T00:47:08.325Z</updated>
    
    <content type="html"><![CDATA[<p>今日问题之——<em><strong>假如给你一个根域或者厂商名，哪些是他的Web资产？应该怎样找这些Web资产？</strong></em></p><p>这也是我们进行<strong>漏洞挖掘</strong>时首先要明确的问题，总的来说就是你在做漏洞挖掘的前准备工作时要有一套自己的流程，千方百计的来让你的信息收集更全面，收集到更多，更有效的资产（这里涉及到一个资产的可靠性问题，在下文中会讲到），这也就是今天我们讲的内容——大型Web资产收集</p><p><em><strong>先行条件：知晓目标的厂商名或根域</strong></em></p><h2 id="１-、拓展根域"><a href="#１-、拓展根域" class="headerlink" title="[１]、拓展根域"></a>[１]、拓展根域</h2><p><strong>拓展根域</strong>简而言之就是根据目标的<strong>厂商名</strong>或者<strong>根域</strong>找到目标更多的<em><strong>根域名</strong></em>，拓展你的攻击面，对应的也就能有更多的web站点来让你进行漏洞挖掘,下面给大家介绍几种方法，这些方法都可以用于拓展根域</p><h3 id="１、CIDR和ASN"><a href="#１、CIDR和ASN" class="headerlink" title="１、CIDR和ASN"></a>１、CIDR和ASN</h3><p><strong>•</strong> <em><strong>CIDR</strong></em>(网段)就理解为指目标的网段，这个很容易理解</p><p><strong>•</strong> <em><strong>ASN</strong></em>(互联网区域)是一个自治系统号，可以理解为一个标识符，标记一个逻辑上的区域，其中包含多个ip段</p><p>  比如百度利用自己的服务器搭建了很多站点，不同根域，例如mbaidu.com,nbaidu.com，也就对应着不同的ip段，例如101.34.31.0&#x2F;24,101.34.35.0&#x2F;24.</p><p>  下面给大家演示一遍利用ASN做信息收集的步骤，这样大家对<em><strong>CIDR</strong></em>和<em><strong>ASN</strong></em>就更容易理解</p><p>  利用asn做信息收集主要分为两个步骤，如下</p><p>  <img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps1.jpg" alt="img"></p><p>任意找一个目标的根域名，这里的厂商以<em><strong>雅虎</strong></em>为例，根域我们用官方根域<em><strong>yahoo.com</strong></em></p><p><strong>•</strong> <em><strong>获取目标IP</strong></em></p><p>  这里直接用<em><strong>shadon</strong></em>的ssl选项搜索目标的根域即可，如下</p><pre><code>ssl:yahoo.com</code></pre><p>  <em><strong>ssl</strong></em>语句用于搜索节点，所以在 Shadon 引擎中搜索 <em><strong>ssl:yahoo.com</strong></em> 的含义是寻找一个已经连接的节点，该节点正在使用 SSL 协议与 yahoo.com 进行数据传输。也就是找它的ip</p><p>  <img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps2.jpg" alt="img"></p><p><em><strong>注意：</strong></em>这样查出来的ip有可能是云厂商的服务器，所以可以去<em><strong>百度云智能</strong></em>查这个ip的厂商再验证一下，网址如下</p><p><em><strong>百度智能云</strong></em>：<a href="https://qifu.baidu.com/">https://qifu.baidu.com/</a></p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps3.jpg" alt="img"> </p><p>可以看到厂商是<em><strong>Yahoo l Europe</strong></em>，说明这就是目标自己的服务器，不是云厂商或者cdn的，如果查到的是腾讯之类的，那就说明是用的云厂商的服务器，到这里我们成功获取了目标的一个ip</p><p><strong>•</strong> <em><strong>获取目标的ASN</strong></em></p><p><em><strong>IP查询ASN在线站点：</strong></em><a href="https://tools.ipip.net/as.php">https://tools.ipip.net/as.php</a></p><p>输入刚才我们找到的ip</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps4.jpg" alt="img"> </p><p><strong>•</strong> <em><strong>获取目标的ip段</strong></em></p><p>  <em><strong>ASN查询IP段在线站点：</strong></em><a href="https://bgpview.io/">https://bgpview.io/</a></p><p>  将上面获得的asn号输入即可查询，如下</p><p>  <img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps5.jpg" alt="img"></p><p>可以看到找到了很多目标的IP段，这就是目标的资产，接下来就可以<em><strong>遍历来探测目标的存活ip</strong></em>来扩大攻击面，或者<em><strong>利用fofa搜索ip段查找其他根域</strong></em>，同样能拓展攻击面，如下</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps6.jpg" alt="img"> </p><p>总结一下我们做了哪些事，如下</p><ul><li><p>通过根域找对应的ip地址</p><ul><li>探查是不是云厂商的服务器</li></ul></li><li><p>通过ip查到对应的ASN</p></li><li><p>通过ASN查找对应区域内的ip段</p></li><li><p>ip段配合fofa查找其他根域</p></li></ul><p>当然这个也有对应的Github项目</p><p><em><strong>Github对应的项目：</strong></em><a href="https://github.com/projectdiscovery/asnmap">https://github.com/projectdiscovery/asnmap</a></p><p>Go CL I 和库，用于使用 ASN 信息快速映射组织网络范围。</p><h3 id="2、备案查询"><a href="#2、备案查询" class="headerlink" title="2、备案查询"></a><em><strong>2、备案查询</strong></em></h3><p>使用<em><strong>天眼查</strong></em>的备案查询功能直接搜目标厂商就可以了，也能看到很多属于目标资产的根域</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps7.jpg" alt="img"> </p><h3 id="3、whois信息"><a href="#3、whois信息" class="headerlink" title="3、whois信息"></a><em><strong>3、whois信息</strong></em></h3><p>• 通过查询目标站点的<em><strong>whois信息</strong></em>来获取目标的更多信息，邮箱，法人，电话号等；</p><p>• 再通过查询到的whois信息来反查出更多站点</p><p>  很多的工具和站点都能实现这个功能，例如下面的</p><p><em><strong>whois + DNSview</strong></em></p><p>  <img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps8.jpg" alt="img"></p><p>再拿到DNSview去反查</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps9.jpg" alt="img"> </p><p>还有什么<em><strong>潮汐指纹、站长之家、freewhois</strong></em>这些都可以查询whois信息或进行反查</p><p>• 潮 汐：<a href="http://finger.tidesec.com/">http://finger.tidesec.com/</a></p><p>• 站长之家：<a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a></p><p>• freewhois：<a href="https://www.whois.com/whois">https://www.whois.com/whois</a></p><p>到这里我们的攻击面增加了很多！此外还有最有价值的一步要走：<em><strong>迭代</strong></em>。对发现的新域重复此过程，查找可能更多的域。</p><h3 id="4、Google-docks"><a href="#4、Google-docks" class="headerlink" title="4、Google docks"></a><em><strong>4、Google docks</strong></em></h3><p>关于搜索引擎，推荐使用google,bing,baidu,当然还有一些不常见的，如：<a href="https://www.dogpile.com/%EF%BC%8Chttps://duckduckgo.com/%E7%AD%89%E7%AD%89%E3%80%82">https://www.dogpile.com/，https://duckduckgo.com/等等。</a></p><p>这里讲的是Google docks中一个与<em><strong>搜索其资产水平相关的语法</strong></em>。为<em><strong>allintext</strong></em>,在谷歌语法中intext就是用于查找网页中的<em><strong>正文内容</strong></em>,并且搜索比<em><strong>intext</strong></em>更广泛</p><p>如何使用<strong>allintext</strong>寻找新域名?步骤如下</p><p>打开已知的目标域名</p><p>找到页脚的版权，或者条款的链接。如：©2021 xx公司保留所有权利</p><p>  <img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps10.jpg" alt="img"></p><pre><code>allintext:&quot;© 京东物流 版权所有&quot;</code></pre><p>注意一定要加引号，达到完全匹配的效果，效果如下</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps11.jpg" alt="img"> </p><h3 id="5、子公司和控股公司"><a href="#5、子公司和控股公司" class="headerlink" title="5、子公司和控股公司"></a><em><strong>5、子公司和控股公司</strong></em></h3><p><em><strong>子公司</strong></em></p><p>• 直接Google搜xx子公司</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps12.jpg" alt="img"> </p><p>当总公司的Web站点挖掘不到漏洞时，也可以像上面这样去尝试寻找并挖掘它的子公司，类似查询子公司的还有很多站点，例如：</p><p>• 天 眼 查:<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></p><p>• 企 查 查:<a href="https://www.qcc.com/">https://www.qcc.com/</a></p><p>• 钉钉企典:<a href="https://www.dingtalk.com/qidian/home?spm=a213l2.13146415.4929779444.89.7f157166W6H4YZ">https://www.dingtalk.com/qidian/home?spm=a213l2.13146415.4929779444.89.7f157166W6H4YZ</a></p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps13.jpg" alt="img"> </p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps14.jpg" alt="img"> </p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps15.jpg" alt="img"> </p><p><em><strong>控股公司</strong></em></p><p>这个目的就在于<em><strong>证明这个资产属于目标</strong></em>，而且还能发现更多属于目标的资产</p><p>这里直接用天眼查就可以，以京东为例子，查看目标对外的投资情况，下面两个网址都可以</p><p><em><strong>小蓝本</strong></em>：<a href="https://www.xiaolanben.com/pc">https://www.xiaolanben.com/pc</a></p><p><em><strong>天眼查</strong></em>：<a href="https://www.tianyancha.com/search?key=&sessionNo=1680878440.21776395">https://www.tianyancha.com/search?key=&amp;sessionNo=1680878440.21776395</a></p><p>例如天眼查，如下：</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps16.jpg" alt="img"> </p><p>其中控股100%的不用说，一定是目标的资产，但是啊但是，控股30%的就不一定了，比如上面这个京东安联保险你如果挖到一个洞提交到京东src，很可能不收，因为这并不完全是目标的资产，所以就可以优先挖控股100%的资产，而不是先挖时间去挖非完全控股的</p><h3 id="6、Dns共享记录"><a href="#6、Dns共享记录" class="headerlink" title="6、Dns共享记录"></a><em><strong>6、Dns共享记录</strong></em></h3><p>通过查询自建DNS服务器的主机来获取相关域名。</p><p>• 查询目标是否存在自建的DNS服务器，以baidu.com为例</p><pre><code>nslookup -query=ns baidu.com 8.8.8.8</code></pre><p>  <img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps17.jpg" alt="img"></p><p>• 通过查询到的DNS服务器反查域名</p><p>  使用的站点：<a href="https://hackertarget.com/find-shared-dns-servers/%EF%BC%88%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%EF%BC%89">https://hackertarget.com/find-shared-dns-servers/（科学上网）</a></p><p>  <img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps18.jpg" alt="img"></p><h2 id="2-、子域名挖掘"><a href="#2-、子域名挖掘" class="headerlink" title="[2]、子域名挖掘"></a><em><strong>[2]、子域名挖掘</strong></em></h2><p>灯塔+子域名挖掘机+Oneforall(集成各大安全搜索引擎api)组合</p><h3 id="灯塔"><a href="#灯塔" class="headerlink" title="灯塔"></a><em><strong>灯塔</strong></em></h3><p>• 优点：易批量操作，使用方便，功能强大，包括字典，poc，指纹都可以自定义，资产收集较为全面</p><p>• 缺点：慢，目标资产多了就是扫三四天，例如jd.com我就扫了三天</p><h3 id="子域名挖掘机"><a href="#子域名挖掘机" class="headerlink" title="子域名挖掘机"></a><em><strong>子域名挖掘机</strong></em></h3><p>• 优点：主动信息收集，速度快，可定制性高，小巧强大，快速发现目标敏感域名资产</p><h3 id="Oneforall"><a href="#Oneforall" class="headerlink" title="Oneforall"></a><em><strong>Oneforall</strong></em></h3><p>• 优点：可集成360，鹰图，fofa，shadon，censys和多个国外安全搜索引擎，配置的越多，收集的越全，自动导出结果资产</p><p>• 缺点：比较慢，而且如果是白嫖党的话有一点点麻烦，很多的搜索引擎都可以免费使用，但是api会定期更换，就需要你也去该对应的配置，总而言之还行</p><p>最后再将上面得到的结果都进行导出，进行去重，最后填入一个如下的表中</p><p>（注意：这里的结果要把****src不收的子域****提前筛选掉，去对应的响应中心公告看看有什么域名是不收的）</p><p>例如挖京东的SRC，<a href="http://fuwu.m.jd.com/">京东服务+ (jd.com)</a>这个url就是不收的，所以我们在漏洞挖掘之前就要先收集目标的资产，确认资产的可靠性，真实性，再去进行一个挖掘，不然很可能挖了半天挖两个洞还不收，也就是今天我们要讲的资产的收集</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps19.jpg" alt="img"> </p><h2 id="3-、端口扫描"><a href="#3-、端口扫描" class="headerlink" title="[3]、端口扫描"></a><em><strong>[3]、端口扫描</strong></em></h2><p>子域名固然能够发现一些薄弱资产，边缘业务，但如果不搜索目标的端口，你在挖掘时可能还会错过目标开放在一些不常见端口的薄弱业务，我在个人渗透中最常见的就是边缘系统的管理页面暴露在不常见的端口下</p><p>goby+nmap+masscan组合</p><h3 id="Goby"><a href="#Goby" class="headerlink" title="Goby"></a><em><strong>Goby</strong></em></h3><p>Goby漏洞探测个人用的比较少，但它的端口扫描功能个人感觉很强，偶尔还能出洞</p><p>在子域名挖掘后，将上面探测到的子域名直接全部放进goby进行扫描就行了，过一段时间就会将结果导出</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps20.jpg" alt="img"> </p><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a><em><strong>nmap</strong></em></h3><p>nmap适用于探测少量目标或单个目标，能在探测目标的同时观察目标服务器开放的服务，版本信息，系统等</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps21.jpg" alt="img"> </p><h3 id="masscan"><a href="#masscan" class="headerlink" title="masscan"></a><em><strong>masscan</strong></em></h3><p>就一个字，快，非常快，但只能扫端口，最常用，也是把上面探测到的子域名直接丢进来批量扫就行了,,扫描完成生成xml文件，如下</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps22.jpg" alt="img"> </p><p>上面三种也是根据当前的环境自己选择</p><p><em><strong>其他</strong></em></p><p><em><strong>httpx</strong></em></p><p>这个用的比较少，但怎么说呢，也有奇效，如下</p><p>例如目标为<em><strong><a href="http://www.baidu.com/">www.baidu.com</a></strong></em></p><p>假设我们探测到<em><strong>目标的ip为”101.34.31.152”</strong></em></p><p>正常的想法是不是拿着101.34.31.152就开始扫端口了，但其实域名也可以拿来扫端口的，假如目标开启了18023端口，偶尔会出现如下情况，我们使用上面三个都没有扫描出</p><pre><code> 101.34.31.153:18023</code></pre><p>但是，使用httpx对域名进行端口扫描，就可以扫出</p><p><a href="http://www.baidu.com:18023/">www.baidu.com:18023</a></p><p>如果这个18023端口开启的是敏感服务，你是不是就错过了？</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps23.jpg" alt="img"> </p><p><a href="https://blog.csdn.net/u010062917/article/details/121878824">(3条消息) Httpx高级使用_WeUjie的博客-CSDN博客</a></p><h2 id="4-、备案号资产"><a href="#4-、备案号资产" class="headerlink" title="[4]、备案号资产"></a><em><strong>[4]、备案号资产</strong></em></h2><p><a href="https://about.jd.com/company">https://about.jd.com/company</a></p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps24.jpg" alt="img"> </p><p>拿主站的备案号进行查询，查出子备案号，使用子备案号备案的网站可能是主站的子域，也可能是公司的一些其他业务，但是，一定属于公司的资产，注意，漏洞挖掘，只要你能证明这个资产属于目标，它就收，当然，报告要写清楚</p><p>查询网址如下</p><p><em><strong>ICP备案查询网</strong></em>： <a href="https://www.beianx.cn/">https://www.beianx.cn/</a></p><p><em><strong>天 眼 查</strong></em>：<a href="https://beian.tianyancha.com/">https://beian.tianyancha.com/</a></p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps25.jpg" alt="img"> </p><h2 id="5-、公众号资产"><a href="#5-、公众号资产" class="headerlink" title="[5]、公众号资产"></a><em><strong>[5]、公众号资产</strong></em></h2><p>很多企业的公众号上也是有功能点的，当然</p><p><img src="/2023/11/04/%E5%A4%A7%E5%9E%8BWeb%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/wps26.jpg" alt="img"> </p><p><em><strong>搜索引擎</strong></em>：<a href="https://weixin.sogou.com/">https://weixin.sogou.com/</a></p><p>可以看到有很多搜索结果，我们只需要关注有微信认证，并且微信认证也可以看出该公众号是否属于目标资产</p><p>当然大型的web项目还有很多相对薄弱的地方，例如小程序,app等，这里就不多讲了，有兴趣的可以自己也去多了解下，也欢迎下来找我交流哦。后续也会在公众号为大家继续更新更多漏洞挖掘技巧。</p>]]></content>
    
    
    <summary type="html">假如给你一个根域或者厂商名，哪些是他的Web资产？应该怎样找这些Web资产？一文带你了解Web资产的信息收集姿势</summary>
    
    
    
    <category term="外部打点" scheme="http://example.com/categories/%E5%A4%96%E9%83%A8%E6%89%93%E7%82%B9/"/>
    
    
    <category term="Web安全" scheme="http://example.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
    <category term="信息收集" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>对SQL注入漏洞原理的思考</title>
    <link href="http://example.com/2023/11/03/%E5%AF%B9SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://example.com/2023/11/03/%E5%AF%B9SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2023-11-03T13:25:29.000Z</published>
    <updated>2023-11-03T14:11:10.972Z</updated>
    
    <content type="html"><![CDATA[<p>这是sql注入</p><span id="more"></span><h1 id="一、一切从输入讲起"><a href="#一、一切从输入讲起" class="headerlink" title="一、一切从输入讲起"></a><strong>一、一切从输入讲起</strong></h1><h2 id="1、信任问题"><a href="#1、信任问题" class="headerlink" title="1、信任问题"></a><strong>1、信任问题</strong></h2><p>安全问题的本质就是信任问题</p><p>例如对一个网站的开发来说</p><ul><li><p>信任普通用户的输入——前台漏洞</p></li><li><p>信息管理员用户的输入——后台漏洞</p></li><li><p>信任离线升级&#x2F;在线升级&#x2F;自动化升级&#x2F;升级包——供应链攻击</p></li><li><p>不信任任何输入——信任代码逻辑——逻辑漏洞</p></li></ul><h2 id="2、防御核心"><a href="#2、防御核心" class="headerlink" title="2、防御核心"></a>2、防御核心</h2><p>对应的安全方案有很多，但都可以简化为</p><blockquote><p><strong>输入</strong>——检测是否存在风险——输出</p></blockquote><p>可以看到，一切都与输入息息相关，毕竟对于黑客来说，能控制的也只有输入，所以挖掘漏洞最好的入口点，也就是从输入开始</p><h1 id="二、控制流与数据流"><a href="#二、控制流与数据流" class="headerlink" title="二、控制流与数据流"></a><strong>二、控制流与数据流</strong></h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>可以将程序员的代码分割为两个部分</p><ul><li>一部分是控制代码走向的<strong>控制流</strong>代码</li><li>另一部分是用来<strong>被</strong>展示，<strong>被</strong>存储，<strong>被</strong>流转的<strong>数据流</strong>(包括输入的数据和程序员设定的数据)</li></ul><h2 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考"></a>2、思考</h2><ul><li><p>为什么要强调数据流操作的这个”被”字?</p><ul><li>“<strong>主谓宾</strong>”层面，数据流的数据不应该有主动权</li></ul></li><li><p>这个<strong>控制流</strong>和<strong>数据流</strong>如何帮助我们更好地去理解输入产生的漏洞？</p><ul><li><p>程序员希望用户输入的一定是数据流，而不是控制流</p></li><li><p><strong>一旦我们输入的数据（数据流）能够以某种方式侵入到控制流时，漏洞就随之产生了</strong></p></li></ul></li></ul><h1 id="三、SQL注入的基础代码样例"><a href="#三、SQL注入的基础代码样例" class="headerlink" title="三、SQL注入的基础代码样例"></a><strong>三、SQL注入的基础代码样例</strong></h1><p>先来看看这样一段存在SQL注入的PHP的代码</p><pre><code class="php">1 &lt;?php2 $db = init_db();3 $username = $_GET[&#39;username&#39;]; 4 $db-&gt;query(&quot;select * from users where username = &#39;$username&#39;&quot;); 5 ?&gt;</code></pre><p>看看这段代码的输入流转：</p><pre><code>输入——php字符变量——SQL语句——数据库</code></pre><p>程序员如果没考虑到这里的安全问题的话，他的控制流程想法如下</p><pre><code>option: selectobject: userssubject: *condition:    key:username    value:$username</code></pre><p>如上，程序员的想法是用户的输入只能影响结构中的value位置，但是我们通过输入恶意代码，就能够跳出数据流，从而影响到控制流，例如我们输入的username为</p><pre><code>admin&#39; and 1=1 #</code></pre><p>此时数据库执行的语句</p><pre><code>select * from users where username=&#39;admin’ and 1=1 #&#39; </code></pre><p>思考：那现在实际执行的控制流程跟程序员想法中的控制流程一样吗？</p><pre><code>option:selectobject:userssubject:*condition:    expression: and        key1:username        value1:admin        key2:1        value2:1</code></pre><p>如上，我们输入的数据被带入数据库中执行，从而导致数据流入侵到了控制流</p><blockquote><p>所以程序员在编程时应该保证用户的数据只能影响数据流，例如上面的value，如果不能保障，那么就会出现漏洞</p></blockquote><p>拓展：</p><ul><li>这里就引出了代码审计的两个核心<ul><li>能否让数据流逃逸到控制流</li><li>业务逻辑可能产生的点在哪（后面再介绍）</li></ul></li></ul><h1 id="四、核心思维"><a href="#四、核心思维" class="headerlink" title="四、核心思维"></a>四、核心思维</h1><h2 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a><strong>1、是什么</strong></h2><blockquote><p>想方设法去执行一条完整的SQL语句，把数据带出来或把命令传进去</p></blockquote><h2 id="2、SQL注入需要关注的点"><a href="#2、SQL注入需要关注的点" class="headerlink" title="2、SQL注入需要关注的点"></a><strong>2、SQL注入需要关注的点</strong></h2><ul><li>编程语言<ul><li>不同编程原因最终目的都是为了将payload送进数据库层进行执行，能看到注入点即可，语言不重要</li></ul></li><li>注入类型<ul><li>比编程语言更重要一些，但其中所有的注入类型都是sql语句不同的写法而已</li></ul></li><li>产生注入的输入点<ul><li>可以理解为我们输入的数据处于SQL语句的哪个位置<ul><li>条件？</li><li>客体（字段）？</li><li>对象（表名）？</li><li>……</li></ul></li></ul></li></ul><h2 id="3、注入挖掘三板斧"><a href="#3、注入挖掘三板斧" class="headerlink" title="3、注入挖掘三板斧"></a><strong>3、注入挖掘三板斧</strong></h2><ul><li>仅仅抓住输⼊</li><li>当数据流⼊侵到控制流时，漏洞就产⽣了</li><li>“数据流⼊侵控制流”产⽣的⻛险点，在于不同层⾯组件的交汇处（如：代码层与数据库层）</li></ul><p>是不是有点看不懂？没关系，更简单的总结如下</p><ul><li>找输入点——哪些位置可能存在注入</li><li>构造payload——如何写入或者执行自己的恶意代码</li><li>找数据库交互的位置——哪些功能可能存在注入？</li></ul><h1 id="五、预编译简述"><a href="#五、预编译简述" class="headerlink" title="五、预编译简述"></a>五、预编译简述</h1><p>先来看看PHP预编译防止SQL注入的案例的</p><pre><code>// 创建连接  $conn = new mysqli($servername, $username, $password, $dbname); // 获取用户输入  $user_input = $_GET[&#39;user_input&#39;];    // 使用预编译语句和参数绑定来防止 SQL 注入  $stmt = $conn-&gt;prepare(&quot;SELECT * FROM users WHERE username = ?&quot;);  $stmt-&gt;bind_param(&quot;s&quot;, $user_input);  $stmt-&gt;execute();    $result = $stmt-&gt;get_result();  </code></pre><p>来看一段Java预编译防止SQL注入的案例</p><pre><code>// 创建数据库连接  Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydatabase&quot;, &quot;root&quot;, &quot;password&quot;);    // 使用预编译语句  String query = &quot;SELECT * FROM users WHERE username = ?&quot;;  PreparedStatement pstmt = conn.prepareStatement(query);  pstmt.setString(1, username); // 设置第一个占位符的值    // 执行查询并处理结果  ResultSet rs = pstmt.executeQuery();  while (rs.next()) &#123;         System.out.println(&quot;User found: &quot; + rs.getString(&quot;username&quot;));  &#125;  </code></pre><p>定了了正常的SQL语句之后，控制逻辑如下：</p><pre><code>option: selectobject: userssubject: *condition:    key:username    value:$username</code></pre><ul><li><p>为什么需要使用预编译？——因为要防止SQL注入</p></li><li><p>为什么要防止SQL注入？——防止数据流入侵到控制流</p></li><li><p>怎样防止数据流入侵到控制流？——将用户的输入限制到输入流</p></li></ul><p>预编译为什么能防止SQL注入</p><blockquote><p>预编译语句通过将SQL<strong>查询语句</strong>与<strong>参数</strong>分开，使用占位符来代表参数，然后将用户输入的数据绑定到占位符上，确保了<strong>输入数据被正确地解释为字符串而不是SQL代码</strong>。因此，无论用户输入什么数据，都不会影响原始查询的结构和意图，从而有效地防止了SQL注入攻击。</p></blockquote><p>也就相当于把下面这部分进行固定了，不允许改动</p><pre><code>option: selectobject: userssubject: *condition:    key:username    value:</code></pre><p>只允许用户控制$username,这样自然就能防止SQL注入</p><blockquote><p>好了，关于SQL注入的研究暂时就到这里了，后面有新的理解的话会在这篇文章中更新，欢迎关注</p></blockquote>]]></content>
    
    
    <summary type="html">为什么会产生SQL注入？SQL注入的核心思维是什么？预编译是如何防止SQL注入的？这篇文章从SQL注入漏洞原理出发，带你深入理解SQL注入的核心。</summary>
    
    
    
    <category term="代码审计" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web安全" scheme="http://example.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ任意文件写入漏洞</title>
    <link href="http://example.com/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-11-03T10:26:27.000Z</published>
    <updated>2023-12-22T02:06:52.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h1><p>漏洞名称：<strong>ActiveMQ任意文件上传漏洞</strong></p><p>漏洞编号：<strong>CVE-2016-3088</strong></p><p>影响版本：Apache ActiveMQ 5.x~5.14.0</p><ul><li>该漏洞基于fileserver应用，ActiveMQ在<strong>5.12.x~5.13.x</strong>版本已经<strong>默认关闭</strong>fileserver，但是被开启</li><li>并且<strong>5.14.0</strong>之后就将fileserver彻底删除了</li><li>只有目标的fileserver服务开启，才存在该漏洞</li></ul><p>随着ActiveMQ的启动，会打开两个端口，61616是工作端口，消息在这个端口进行传递；8161是Web管理页面端口</p><p>登录的默认账密：<strong>admin&#x2F;admin</strong></p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>漏洞产生原因：</p><p>ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中</p><ul><li>admin是管理员页面</li><li>api是接口</li><li>fileserver是储存文件的接口</li></ul><p>admin和api都需要登录后才能使用，fileserver无需登录。</p><p>本漏洞出现在fileserver应用中，漏洞原理其实非常简单，就是fileserver支持写入（PUT请求）文件（但不解析jsp），同时支持移动文件（MOVE请求）。所以，我们只需要写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件上传漏洞。</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>因为CVE-2016-3088这个漏洞环境在vulhub上有，所以这里我直接选择使用vulhub来搭建这个漏洞环境，漏洞环境位于vulhub中的ActiveMQ目录下</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-nwml.png" alt="image-nwml"></p><p>具体的搭建这里就不讲了，搭建之后会开启两个端口服务，就是上面我们提到的ActiveMQ服务对应的两个端口</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-phgq.png" alt="image-phgq"></p><p>这里直接访问本机的8161端口即可来到ActiveMQ的web页面</p><h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ul><li>vulhub靶机：192.168.149.129</li><li>物 理 机：172.21.126.244</li></ul><p>Web页面：<a href="http://192.168.149.129:8161/">http://192.168.149.129:8161</a></p><p>访问之后页面如下：</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-nsuy.png" alt="image-nsuy"></p><h3 id="探测版本信息"><a href="#探测版本信息" class="headerlink" title="探测版本信息"></a>探测版本信息</h3><p>访问如下页面即可探测到该ActiveMQ应用的版本信息</p><pre><code>http://host:8161/admin/index.jsp?printable=true</code></pre><p>注意：因为admin应用是管理员页面，所以需要登录,尝试默认密码登录即可</p><p>结果如下</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-mpyu.png" alt="image-mpyu"></p><p>可以看到目前的版本是<strong>5.11.1</strong>，为存在漏洞的应用版本，尝试利用该漏洞</p><h3 id="探测绝对路径"><a href="#探测绝对路径" class="headerlink" title="探测绝对路径"></a>探测绝对路径</h3><p>访问如下路径，该路径是一个测试页面，展示了ActiveMQ应用的绝对路径</p><pre><code>http://host:8161/admin/test/systemProperties.jsp</code></pre><p>如下</p><p>找到activemq.home，即为该应用的绝对路径，如下</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-yscj.png" alt="image-yscj"></p><h3 id="上传webshell"><a href="#上传webshell" class="headerlink" title="上传webshell"></a>上传webshell</h3><pre><code class="jsp">PUT /fileserver/2.txt HTTP/1.1Host: localhost:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 120976webshell...</code></pre><p>这个请求体的位置就是jsp一句话木马的内容，而请求fileserver&#x2F;2.txt就是利用fileserver支持put请求写入文件的特性，写入2.txt,那有人问了，为什么不直接写入jsp文件，而是写入为txt文件？</p><blockquote><p>这是因为前面也讲到了，fileserver虽然支持put请求写入文件，但是无法解析jsp，所以只需要写入一个txt文件，待会再利用move请求移动文件的同时进行重命名修改后缀名即可</p></blockquote><p>直接写入jsp文件也行，只是动静稍微大一点，隐蔽性差点，如果存在上传的waf就很可能被kill了，我们的目标是先把我们的马上传上去，动静自然越小越好</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-vyim.png" alt="image-vyim"></p><p>回显204即为上传成功，注意这里要使用PUT请求</p><p>此时可以访问上传的路径看看文件是否被成功上传</p><pre><code class="http">http://host:8161/fileserver/2.txt</code></pre><p>这里的2.txt是刚才put请求中上传的文件，师傅们根据自己的场景来就行</p><p>访问之后结果如下</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-lrts.png" alt="image-lrts"></p><p>可以看到已经成功上传了</p><h3 id="移动木马位置"><a href="#移动木马位置" class="headerlink" title="移动木马位置"></a>移动木马位置</h3><p>这里已经成功上传了，但是还有一个问题，这个fileserver目录下的jsp文件无法解析，这时候应该怎么办呢？这是我们就可以利用fileserver支持的另一个请求——move（将木马的位置移动到能够解析的位置）</p><pre><code class="htp">MOVE /fileserver/2.txt HTTP/1.1Destination: file:///opt/activemq/webapps/api/2.jspHost: localhost:8161Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Length: 0</code></pre><p>这里的destination请求头的值就是你要移动的目标位置，因为我这里的靶场探测到目标的ActiveMQ的绝对路径下的&#x2F;opt&#x2F;activemq目录，所以这里我们选择把木马移动到activemq的webapps&#x2F;api目录下，如下</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-cxnr.png" alt="image-cxnr"></p><p>同样的，204回显代表移动成功，此时可以访问如下路径查看是否成功移动（需要登录)</p><pre><code class="http">http://host:8161/api</code></pre><p>可以看到已经成功移动到了api目录下</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-jscz.png" alt="image-jscz"></p><h3 id="webshell使用"><a href="#webshell使用" class="headerlink" title="webshell使用"></a>webshell使用</h3><p>我们可以访问这个2.jsp文件，看看木马能否正常使用</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-zisj.png" alt="image-zisj"></p><p>可以看到，能够正常访问和解析，但是有报错，这个不影响，尝试命令执行</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-qzlk.png" alt="image-qzlk"></p><p>可以看到直接就是root权限，因为api目录是root权限创建的</p><p>尝试连接webshell管理工具，这里我使用的蚁剑</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-khfa.png" alt="image-khfa"></p><p>这里还有一个问题，webshell连接工具在连接时会显示无法连接，甚至出现报错，请问这是什么原因呢？</p><blockquote><p>其实仔细想一下就能理解为什么会报错了，你想一下你浏览器访问到这个2.jsp的前提是什么？前提就是登录，不登录就无法查看，那我们应该<strong>怎么让蚁剑模拟登录</strong>呢？——设置Cookie</p></blockquote><p>这里的Cookie没有鉴权作用，真正起到鉴权作用的是</p><blockquote><p>Authorization: Basic YWRtaW46YWRtaW4&#x3D;</p></blockquote><p>也就是账号密码</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-dvab.png" alt="image-dvab"></p><p>再测试连接</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-hncu.png" alt="image-hncu"></p><p>连接成功</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-sjrb.png" alt="image-sjrb"></p><p>成功拿到目标机器的root权限</p><h1 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h1><p>1、ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。</p><p>2、通过移除 conf\jetty.xml 的以下配置来禁用 ActiveMQ Fileserver 功能</p><p><img src="/2023/11/03/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E/image-eyza.png" alt="image-eyza"></p>]]></content>
    
    
    <summary type="html">Active mq最近爆出了RCE，使得越来越多的人回来关注mq的安全情况，本文讲解了mq的任意文件上传漏洞(CVE-2016-3088)的原理，漏洞成因和复现过程。</summary>
    
    
    
    <category term="漏洞复现" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
</feed>
